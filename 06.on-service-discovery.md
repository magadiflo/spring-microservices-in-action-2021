# Sobre el service discovery

Pág. 148

---

En cualquier arquitectura distribuida, necesitamos encontrar el nombre de host o la dirección IP donde se encuentra una
máquina. Este concepto ha existido desde el comienzo de la informática distribuida y se conoce formalmente
como `"service discovery"`. El service discovery puede ser algo tan simple como mantener un archivo de
propiedades con las direcciones de todos los servicios remotos utilizados por una aplicación, o algo tan formalizado
como un repositorio `Universal Description, Discovery and Integration (UDDI)`. El service discovery es
fundamental para las aplicaciones de microservicios basadas en la nube por dos razones clave:

- `Escalamiento horizontal o  scale out`: este patrón generalmente requiere ajustes en la arquitectura de la aplicación,
  como agregar más instancias de un servicio dentro de un servicio en la nube y más contenedores.


- `Resiliencia`: este patrón se refiere a la capacidad de absorber el impacto de los problemas dentro de una
  arquitectura o servicio sin afectar el negocio. Las arquitecturas de microservicios deben ser extremadamente sensibles
  para evitar que un problema en un solo servicio (o instancia de servicio) se propague en cascada hacia los
  consumidores del servicio.

En primer lugar, **el service discovery permite al equipo de aplicaciones escalar rápidamente
(horizontalmente) la cantidad de instancias de servicios que se ejecutan en un entorno.** Los consumidores del servicio
se abstraen de la ubicación física del servicio. Debido a que los consumidores del servicio no conocen la ubicación
física de las instancias de servicio reales, se pueden agregar o eliminar nuevas instancias de servicio del conjunto de
servicios disponibles.

Esta capacidad para escalar servicios rápidamente sin interrumpir a los consumidores del servicio es un concepto
atractivo. Puede ayudar a un equipo de desarrollo, acostumbrado a construir una aplicación monolítica para un solo
cliente (por ejemplo, para un único cliente), a dejar de pensar en escalar solo en términos de agregar hardware más
grande y mejor `(escalamiento vertical)`, y en su lugar, adoptar el enfoque más robusto de escalar agregando más
servidores con más servicios `(escalamiento horizontal)`.

Un enfoque monolítico suele llevar a los equipos de desarrollo a comprar en exceso sus necesidades de capacidad. Los
aumentos de capacidad se producen en grupos y picos y rara vez son un proceso fluido y constante. Por ejemplo, considere
el número incremental de request realizadas a sitios de comercio electrónico antes de algunos días festivos. Los
microservicios nos permiten escalar nuevas instancias de servicios bajo demanda. El service discovery ayuda a
abstraer estas implementaciones para que ocurran lejos del consumidor del servicio.

El segundo beneficio del service discovery es que ayuda a aumentar la resiliencia de la aplicación. Cuando una
instancia de un microservicio se vuelve inestable o no está disponible, la mayoría de los motores de descubrimiento de
servicios eliminan esa instancia de su lista interna de servicios disponibles. El daño causado por un servicio caído se
minimiza porque el motor de service discovery redirige los servicios evitando el servicio no disponible.

Veamos ahora cómo puede implementar un mecanismo sólido de service discovery para sus aplicaciones basadas en
la nube.

## Service discovery en la nube

La solución para un entorno de microservicios basado en la nube es utilizar un mecanismo de service discovery
que sea:

- `Altamente disponible`: el service discovery debe ser capaz de admitir un entorno de agrupación en
  clústeres "caliente" donde las búsquedas de servicios se puedan compartir entre varios nodos en un clúster de
  service discovery. Si un nodo deja de estar disponible, otros nodos del clúster deberían poder hacerse
  cargo.<br><br>
  **Un clúster se puede definir como un grupo de múltiples instancias de servidor.** Todas las instancias de este
  entorno tienen una configuración idéntica y trabajan juntas para ofrecer alta disponibilidad, confiabilidad y
  escalabilidad. Un clúster, combinado con un load balancer, puede ofrecer conmutación por error para prevenir
  interrupciones del servicio y replicación de sesiones para almacenar datos de sesión.


- `Peet-to-peer`: cada nodo en el clúster de service discovery comparte el estado de una instancia de
  servicio.


- `Load balancer`, el service discovery necesita equilibrar dinámicamente la carga de las solicitudes en todas
  las instancias de servicio. Esto garantiza que las invocaciones de servicio se distribuyan entre todas las instancias
  de servicio gestionadas por él. En muchos sentidos, el service discovery reemplaza a los balanceadores de
  carga más estáticos y administrados manualmente que se encuentran en muchas de las primeras implementaciones de
  aplicaciones web.


- `Resilient`, el cliente del service discovery debe almacenar en caché local la información del servicio.
  El almacenamiento en caché local permite la degradación gradual de la función de descubrimiento de
  servicios, de modo que si el servicio discovery service deja de estar disponible, las aplicaciones aún
  pueden funcionar y localizar los servicios en función de la información mantenida en su caché local.


- `Fault tolerant`, el service discovery debe detectar cuándo una instancia de servicio no está en buen estado
  y eliminar esa instancia de la lista de servicios disponibles que pueden aceptar solicitudes de clientes. Debe
  detectar estas fallas en los servicios y tomar medidas sin intervención humana.

En las siguientes secciones, vamos a

- Explicar la arquitectura conceptual de cómo funciona un agente de service discovery basado en la nube.
- Mostrarle cómo el almacenamiento en caché y el load balancing del lado del cliente permiten que el servicio
  continúe funcionando incluso cuando el agente service discovery no está disponible.
- Mostrarle cómo implementar el service discovery utilizando Spring Cloud y los agentes de descubrimiento de
  servicios Eureka de Netflix.

