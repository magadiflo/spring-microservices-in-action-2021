# Building Microservices With Spring Boot

---

## La historia del arquitecto: diseño de la arquitectura de microservicios

El papel de un arquitecto en un proyecto de software es proporcionar un modelo funcional del problema que debe
resolverse. El arquitecto proporciona el andamiaje sobre el cual los desarrolladores construirán su código para que
todas las piezas de la aplicación encajen. Al crear un microservicio, el arquitecto de un proyecto se centra en tres
tareas clave:

- Descomponer el problema empresarial
- Establecer granularidad del servicio
- Definición de las interfaces de servicio.

La `Figura 3.3` muestra cómo el código de la aplicación y el modelo de datos se “fragmentan” en partes individuales.

**NOTA**
> Creamos bases de datos individuales para cada servicio, pero también puede compartir bases de datos entre los
> servicios.

Después de dividir un dominio problemático en partes discretas, a menudo nos encontraremos luchando por determinar si
hemos alcanzado el nivel adecuado de granularidad para nuestros servicios. Un microservicio que sea demasiado grueso o
fino tendrá varios atributos reveladores, que analizaremos en breve.

`Figura 3.3` La aplicación O-stock se desglosa desde una aplicación monolítica en servicios individuales más pequeños
que se implementan de forma independiente unos de otros

![11.from-monolithic-to-microservices.png](./assets/11.from-monolithic-to-microservices.png)

## La historia del desarrollador: creación de un microservicio con Spring Boot y Java

En esta sección, exploraremos las prioridades del desarrollador al crear el microservicio de licencias a partir del
modelo de dominio O-stock.

**NOTA**
> Creamos el esqueleto del servicio de licencias en el capítulo anterior.

Las siguientes secciones ver en el archivo `README.md` del microservicio `licensing-service`:

1. Implementar una clase de controlador Spring Boot para mapear un punto final para exponer los puntos finales del
   servicio de licencias.
2. Implementar la internacionalización para que los mensajes se puedan adaptar a diferentes idiomas.
3. Implementar Spring HATEOAS para proporcionar suficiente información para que el usuario pueda interactuar con el
   servidor.

## La historia del DevOps: construcción para los rigores del tiempo de ejecución

Si bien DevOps es un campo de TI rico y emergente, para el ingeniero de DevOps, el diseño del microservicio tiene que
ver con la gestión del servicio después de que entra en producción. Escribir el código suele ser la parte fácil.
Mantenerlo funcionando es la parte difícil. Comenzaremos nuestro esfuerzo de desarrollo de microservicios con cuatro
principios y los desarrollaremos más adelante en el libro:

- `Un microservicio debe ser autónomo`. También debería poder implementarse de forma independiente con múltiples
  instancias del servicio iniciadas y desmanteladas con un único artefacto de software.


- `Un microservicio debe ser configurable`. Cuando se inicia una instancia de servicio, debe leer los datos que necesita
  para configurarse desde una ubicación central o transmitir su información de configuración como variables de entorno.
  No debería ser necesaria ninguna intervención humana para configurar el servicio.


- `Una instancia de microservicio debe ser transparente para el cliente`. El cliente nunca debe saber la ubicación
  exacta de un servicio. En cambio, un cliente de microservicio debería hablar con un agente de descubrimiento de
  servicios. Eso permite que la aplicación ubique una instancia de un microservicio sin tener que conocer su ubicación
  física.


- `Un microservicio debe comunicar su estado`. Esta es una parte fundamental de su arquitectura en la nube. Las
  instancias de microservicio fallarán y los agentes de descubrimiento deberán evitar las instancias de servicio
  incorrectas. En este libro, usaremos `Spring Boot Actuator` para mostrar el estado de cada microservicio.

Estos cuatro principios exponen la paradoja que puede existir con el desarrollo de microservicios. Los microservicios
son más pequeños en tamaño y alcance, pero su uso introduce más partes móviles en una aplicación porque los
microservicios se distribuyen y ejecutan de forma independiente unos de otros en sus propios contenedores. Esto
introduce un alto grado de coordinación y más oportunidades de puntos de falla en la aplicación.

Desde una perspectiva de `DevOps`, debe abordar las necesidades operativas de un microservicio desde el principio y
traducir estos cuatro principios en un conjunto estándar de eventos del ciclo de vida que ocurren cada vez que se
construye e implementa un microservicio en un entorno. Los cuatro principios se pueden asignar a los siguientes ciclos
de vida operativos. La figura 3.9 muestra cómo encajan estos cuatro pasos.

- `Montaje del servicio`: cómo empaqueta e implementa su servicio para garantizar la repetibilidad y la coherencia, de
  modo que el mismo código de servicio y tiempo de ejecución se implementen exactamente de la misma manera.

- `Arranque del servicio`: cómo separar el código de configuración específico de su aplicación y entorno del código de
  tiempo de ejecución para que pueda iniciar e implementar una instancia de microservicio rápidamente en cualquier
  entorno sin intervención humana.

- `Registro/descubrimiento de servicio`: cuando se implementa una nueva instancia de microservicio, cómo hacer que la
  nueva instancia de servicio sea detectable por otros clientes de aplicaciones.

- `Monitoreo de servicios`: en un entorno de microservicios, es común que se ejecuten varias instancias del mismo
  servicio debido a necesidades de alta disponibilidad. Desde una perspectiva de DevOps, es necesario monitorear las
  instancias de microservicios y asegurarse de que cualquier falla se direccione alrededor de las instancias de servicio
  fallidas y que se eliminen.

![12.devops-history.png](./assets/12.devops-history.png)