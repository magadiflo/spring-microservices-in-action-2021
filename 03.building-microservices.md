# Building Microservices With Spring Boot

---

## La historia del arquitecto: diseño de la arquitectura de microservicios

El papel de un arquitecto en un proyecto de software es proporcionar un modelo funcional del problema que debe
resolverse. El arquitecto proporciona el andamiaje sobre el cual los desarrolladores construirán su código para que
todas las piezas de la aplicación encajen. Al crear un microservicio, el arquitecto de un proyecto se centra en tres
tareas clave:

- Descomponer el problema empresarial
- Establecer granularidad del servicio
- Definición de las interfaces de servicio.

La `Figura 3.3` muestra cómo el código de la aplicación y el modelo de datos se “fragmentan” en partes individuales.

**NOTA**
> Creamos bases de datos individuales para cada servicio, pero también puede compartir bases de datos entre los
> servicios.

Después de dividir un dominio problemático en partes discretas, a menudo nos encontraremos luchando por determinar si
hemos alcanzado el nivel adecuado de granularidad para nuestros servicios. Un microservicio que sea demasiado grueso o
fino tendrá varios atributos reveladores, que analizaremos en breve.

`Figura 3.3` La aplicación O-stock se desglosa desde una aplicación monolítica en servicios individuales más pequeños
que se implementan de forma independiente unos de otros

![11.from-monolithic-to-microservices.png](./assets/11.from-monolithic-to-microservices.png)

## La historia del desarrollador: creación de un microservicio con Spring Boot y Java

En esta sección, exploraremos las prioridades del desarrollador al crear el microservicio de licencias a partir del
modelo de dominio `O-stock`.

## Dependencias

````xml
<!--Spring Boot 3.2.5-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

Para verificar las dependencias de Spring incorporadas por Spring Boot en nuestro servicio de licencias, podemos usar el
`dependency:tree` de `Maven goal`.

Ubicados en la raíz del microservicio `licensing-service` ejecutamos el siguiente comando:

````bash
$ .\mvnw dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------< dev.magadiflo:licensing-service >-------------------
[INFO] Building licensing-service 0.0.1-SNAPSHOT
[INFO]   from pom.xml
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- dependency:3.6.1:tree (default-cli) @ licensing-service ---
[INFO] dev.magadiflo:licensing-service:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter-actuator:jar:3.2.5:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:3.2.5:compile
[INFO] |  |  +- org.springframework.boot:spring-boot:jar:3.2.5:compile
[INFO] |  |  +- org.springframework.boot:spring-boot-autoconfigure:jar:3.2.5:compile
[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:3.2.5:compile
[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.4.14:compile
[INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.4.14:compile
[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.21.1:compile
[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.21.1:compile
[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:2.0.13:compile
[INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:2.1.1:compile
[INFO] |  |  \- org.yaml:snakeyaml:jar:2.2:compile
[INFO] |  +- org.springframework.boot:spring-boot-actuator-autoconfigure:jar:3.2.5:compile
[INFO] |  |  +- org.springframework.boot:spring-boot-actuator:jar:3.2.5:compile
[INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.15.4:compile
[INFO] |  |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.15.4:compile
[INFO] |  |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.15.4:compile
[INFO] |  |  \- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.15.4:compile
[INFO] |  +- io.micrometer:micrometer-observation:jar:1.12.5:compile
[INFO] |  |  \- io.micrometer:micrometer-commons:jar:1.12.5:compile
[INFO] |  \- io.micrometer:micrometer-jakarta9:jar:1.12.5:compile
[INFO] |     \- io.micrometer:micrometer-core:jar:1.12.5:compile
[INFO] |        +- org.hdrhistogram:HdrHistogram:jar:2.1.12:runtime
[INFO] |        \- org.latencyutils:LatencyUtils:jar:2.0.3:runtime
[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:3.2.5:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:3.2.5:compile
[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.15.4:compile
[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.15.4:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:3.2.5:compile
[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:10.1.20:compile
[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-el:jar:10.1.20:compile
[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:10.1.20:compile
[INFO] |  +- org.springframework:spring-web:jar:6.1.6:compile
[INFO] |  |  \- org.springframework:spring-beans:jar:6.1.6:compile
[INFO] |  \- org.springframework:spring-webmvc:jar:6.1.6:compile
[INFO] |     +- org.springframework:spring-aop:jar:6.1.6:compile
[INFO] |     +- org.springframework:spring-context:jar:6.1.6:compile
[INFO] |     \- org.springframework:spring-expression:jar:6.1.6:compile
[INFO] +- org.projectlombok:lombok:jar:1.18.32:compile
[INFO] \- org.springframework.boot:spring-boot-starter-test:jar:3.2.5:test
[INFO]    +- org.springframework.boot:spring-boot-test:jar:3.2.5:test
[INFO]    +- org.springframework.boot:spring-boot-test-autoconfigure:jar:3.2.5:test
[INFO]    +- com.jayway.jsonpath:json-path:jar:2.9.0:test
[INFO]    |  \- org.slf4j:slf4j-api:jar:2.0.13:compile
[INFO]    +- jakarta.xml.bind:jakarta.xml.bind-api:jar:4.0.2:test
[INFO]    |  \- jakarta.activation:jakarta.activation-api:jar:2.1.3:test
[INFO]    +- net.minidev:json-smart:jar:2.5.1:test
[INFO]    |  \- net.minidev:accessors-smart:jar:2.5.1:test
[INFO]    |     \- org.ow2.asm:asm:jar:9.6:test
[INFO]    +- org.assertj:assertj-core:jar:3.24.2:test
[INFO]    |  \- net.bytebuddy:byte-buddy:jar:1.14.13:test
[INFO]    +- org.awaitility:awaitility:jar:4.2.1:test
[INFO]    +- org.hamcrest:hamcrest:jar:2.2:test
[INFO]    +- org.junit.jupiter:junit-jupiter:jar:5.10.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-api:jar:5.10.2:test
[INFO]    |  |  +- org.opentest4j:opentest4j:jar:1.3.0:test
[INFO]    |  |  +- org.junit.platform:junit-platform-commons:jar:1.10.2:test
[INFO]    |  |  \- org.apiguardian:apiguardian-api:jar:1.1.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-params:jar:5.10.2:test
[INFO]    |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.10.2:test
[INFO]    |     \- org.junit.platform:junit-platform-engine:jar:1.10.2:test
[INFO]    +- org.mockito:mockito-core:jar:5.7.0:test
[INFO]    |  +- net.bytebuddy:byte-buddy-agent:jar:1.14.13:test
[INFO]    |  \- org.objenesis:objenesis:jar:3.3:test
[INFO]    +- org.mockito:mockito-junit-jupiter:jar:5.7.0:test
[INFO]    +- org.skyscreamer:jsonassert:jar:1.5.1:test
[INFO]    |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO]    +- org.springframework:spring-core:jar:6.1.6:compile
[INFO]    |  \- org.springframework:spring-jcl:jar:6.1.6:compile
[INFO]    +- org.springframework:spring-test:jar:6.1.6:test
[INFO]    \- org.xmlunit:xmlunit-core:jar:2.9.1:test
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  4.500 s
[INFO] Finished at: 2024-05-01T18:45:30-05:00
[INFO] ------------------------------------------------------------------------
````

**NOTA**
> Estas dependencias las podemos ver con nuestro propio IDE de IntelliJ IDEA, pero se muestra aquí una manera de cómo
> ver las dependencias que estamos usando actualmente en nuestro proyecto a través de la línea de comandos apoyándonos
> de maven.

## 1. Implementar una clase de controlador Spring Boot para mapear un punto final para exponer los puntos finales del servicio de licencias

Antes de empezar a codear nuestro controlador y servicio, necesitamos definir nuestro modelo:

````java

@ToString
@Getter
@Setter
public class License {
    private Integer id;
    private String licenseId;
    private String description;
    private String organizationId;
    private String productName;
    private String licenseType;
}
````

Ahora, crearemos nuestra clase de servicio. Por lo pronto solo retornaremos mensajes desde cada método implementado:

````java

@Service
public class LicenseService {

    public License getLicense(String licenseId, String organizationId) {
        License license = new License();
        license.setId(new Random().nextInt(1000));
        license.setLicenseId(licenseId);
        license.setOrganizationId(organizationId);
        license.setDescription("Software product");
        license.setProductName("Ostock");
        license.setLicenseType("full");
        return license;
    }

    public String createLicense(License license, String organizationId) {
        String responseMessage = null;
        if (license != null) {
            license.setOrganizationId(organizationId);
            responseMessage = "Este es el POST y el objeto es: %s".formatted(license.toString());
        }
        return responseMessage;
    }

    public String updateLicense(License license, String organizationId) {
        String responseMessage = null;
        if (license != null) {
            license.setOrganizationId(organizationId);
            responseMessage = "Este es el PUT y el objeto es: %s".formatted(license.toString());
        }
        return responseMessage;
    }

    public String deleteLicense(String licenseId, String organizationId) {
        return "Eliminando licencia con id %s para la organización %s".formatted(licenseId, organizationId);
    }

}
````

Finalmente, implementamos nuestro controlador:

````java
/**
 * {organizationId} es un marcador de posición que indica cómo espera que se parametrice la URL con un
 * OrganizationId pasado en cada llamada. El uso de OrganizationId en la URL le permite diferenciar
 * entre los diferentes clientes que podrían utilizar su servicio.
 */

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/v1/organization/{organizationId}/license")
public class LicenseController {

    private final LicenseService licenseService;

    @GetMapping(path = "/{licenseId}")
    public ResponseEntity<License> getLicense(@PathVariable String organizationId, @PathVariable String licenseId) {
        License license = this.licenseService.getLicense(licenseId, organizationId);
        return ResponseEntity.ok(license);
    }

    @PutMapping
    public ResponseEntity<String> updateLicense(@PathVariable String organizationId, @RequestBody License license) {
        return ResponseEntity.ok(this.licenseService.updateLicense(license, organizationId));
    }

    @PostMapping
    public ResponseEntity<String> createLicense(@PathVariable String organizationId, @RequestBody License license) {
        return ResponseEntity.ok(this.licenseService.createLicense(license, organizationId));
    }

    @DeleteMapping(path = "/{licenseId}")
    public ResponseEntity<String> deleteLicense(@PathVariable String organizationId, @PathVariable String licenseId) {
        return ResponseEntity.ok(this.licenseService.deleteLicense(licenseId, organizationId));
    }

}
````

### Ejecutando implementación

Ejecutamos nuestra aplicación para probar los endpoints implementados. Podemos usar nuestro ide, pero para variar
utilizaré la línea de comando ejecutando la siguiente instrucción de maven en la raíz de nuestro
microservicio `licensing-service`:

````bash
$ .\mvnw spring-boot:run

[INFO] Scanning for projects...
[.....]
[INFO] Attaching agents: []

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.5)

2024-05-02T12:13:52.074-05:00  INFO 8720 --- [licensing-service] [           main] d.m.l.app.LicensingServiceApplication    : Starting LicensingServiceApplication using Java 21.0.1 with PID 8720 (M:\PROGRAMACION\DESARROLLO_JAVA_SPRING\08.book_ms-in-action-2021\spring-microservices-in-action-2021\projects\licensing-service\target\classes started by USUARIO in M:\PROGRAMACION\DESARROLLO_JAVA_SPRING\08.book_ms-in-action-2021\spring-microservices-in-action-2021\projects\licensing-service)
2024-05-02T12:13:52.079-05:00  INFO 8720 --- [licensing-service] [           main] d.m.l.app.LicensingServiceApplication    : No active profile set, falling back to 1 default profile: "default"
2024-05-02T12:13:53.852-05:00  INFO 8720 --- [licensing-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)
2024-05-02T12:13:53.872-05:00  INFO 8720 --- [licensing-service] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2024-05-02T12:13:53.873-05:00  INFO 8720 --- [licensing-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.20]
2024-05-02T12:13:53.993-05:00  INFO 8720 --- [licensing-service] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2024-05-02T12:13:53.994-05:00  INFO 8720 --- [licensing-service] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1843 ms
2024-05-02T12:13:54.955-05:00  INFO 8720 --- [licensing-service] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint(s) beneath base path '/actuator'
2024-05-02T12:13:55.046-05:00  INFO 8720 --- [licensing-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path ''
2024-05-02T12:13:55.064-05:00  INFO 8720 --- [licensing-service] [           main] d.m.l.app.LicensingServiceApplication    : Started LicensingServiceApplication in 3.669 seconds (process running for 4.179)
````

Ahora, usando otra ventana, podemos realizar las llamadas a los endpoints y verificar su funcionamiento:

````bash
$ curl -v http://localhost:8080/v1/organization/optimaGrowth/license/0235431845 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
<
{
  "id": 595,
  "licenseId": "0235431845",
  "description": "Software product",
  "organizationId": "optimaGrowth",
  "productName": "Ostock",
  "licenseType": "full"
}
````

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"licenseId\": \"0235454846\", \"description\": \"Software product\", \"productName\": \"Teclado\", \"licenseType\": \"full\"}" http://localhost:8080/v1/organization/optimaGrowth/license
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 168
< Date: Thu, 02 May 2024 17:27:25 GMT
<
Este es el POST y el objeto es: License(id=null, licenseId=0235454846, description=Software product, organizationId=optimaGrowth, productName=Teclado, licenseType=full)
````

````bash
$ curl -v -X DELETE http://localhost:8080/v1/organization/optimaGrowth/license/0235431845
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 72
< Date: Thu, 02 May 2024 17:28:12 GMT
<
Eliminando licencia con id 0235431845 para la organización optimaGrowth
````

## 2. Implementar la internacionalización para que los mensajes se puedan adaptar a diferentes idiomas

La internacionalización conocida como `i18n (abreviatura de "internationalization", ello debido a que entre la primera
i y la última n de dicha palabra hay 18 letras)` es un requisito imprescindible para que tu aplicación pueda adaptarse a
diferentes idiomas. **El objetivo principal aquí es desarrollar aplicaciones que ofrezcan contenido en múltiples
formatos e idiomas.** En esta sección, explicaremos cómo agregar internalización al servicio de licencias que creamos
anteriormente.

[Internacionalización](https://docs.spring.io/spring-boot/reference/features/internationalization.html)

`Spring Boot` admite mensajes localizados para que su aplicación pueda atender a usuarios con diferentes preferencias
de idioma. De forma predeterminada, `Spring Boot` busca la presencia de un `messages` paquete de recursos en la raíz
del `classpath`.

**NOTA**
> La configuración automática se aplica cuando el archivo de propiedades predeterminado para el paquete de recursos
> configurado está disponible (`messages.properties` de forma predeterminada). Si su paquete de recursos contiene solo
> archivos de propiedades específicos del idioma, **deberá agregar el predeterminado**. Si no se encuentra ningún
> archivo de propiedades que coincida con alguno de los nombres base configurados, no habrá ningún `MessageSource`
> configurado automáticamente.

Primero, crearemos una clase de configuración donde agregaremos dos beans: `LocaleResolver` y
un `ResourceBundleMessageSource`.

````java

@Configuration
public class InternationalizationConfig {
    @Bean
    public LocaleResolver localeResolver() {
        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();   // (1)
        localeResolver.setDefaultLocale(Locale.of("es"));                               // (2)
        return localeResolver;
    }

    @Bean
    public ResourceBundleMessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setUseCodeAsDefaultMessage(true);                                 // (3)
        messageSource.setBasename("i18n/messages");                                     // (4)
        return messageSource;
    }
}
````

**DONDE**

- `(1)`, `AcceptHeaderLocaleResolver` usa el encabezado `Accept-Language` de las solicitudes HTTP para determinar el
  idioma. Este enfoque es más adecuado para servicios REST porque **no depende de sesiones ni de cookies.**
  Los clientes pueden especificar el idioma preferido enviando el encabezado correspondiente.
- `(2)`, establece el idioma español (`es`) como predeterminado.
- `(3)`, como está en `true`, le decimos que no arroje un error si no se encuentra un mensaje, sino que devuelva el
  código del mensaje. Por ejemplo `license.creates.message`.
- `(4)`, establece el nombre base de los archivos de propiedades de idiomas. En este caso estamos indicando que el
  nombre base será `messages` y está ubicado en el classpath dentro del directorio `i18n`.

Ahora, configuraremos los `messages`. Para este ejemplo, usaremos mensajes en inglés y en español.
Para lograr esto, crearemos el directorio `/i18n` donde tendremos agrupados los archivos de mensajes. Este directorio
lo tendremos dentro de la carpeta fuente `/src/main/resources`:

- messages_en.properties
- messages_es.properties

**NOTA**
> Podríamos haber creado también un archivo por defecto `messages.properties`, pero como hemos definido un bean
> llamado `LocalResolver` donde estamos estableciendo nuestro idioma por defecto, entonces ya no es necesario, dado que
> estamos diciendo que por defecto nuestro archivo de idioma será `messages_es.properties`.

Los dos listados siguientes muestran cómo deberían verse los archivos `messages_es.properties`
y `messages_en.properties`.

````properties
license.create.message=¡Licencia creada %s con éxito!
license.update.message=Licencia %s actualizada con éxito!
````

````properties
license.create.message=License created %s successfully!
license.update.message=License %s updated successfully!
````

Ahora que hemos implementado los mensajes y la anotación `@Beans`, podemos actualizar el código en nuestro controlador
o servicio para llamar al recurso del mensaje. La siguiente lista muestra cómo se hace esto.

````java

@RequiredArgsConstructor
@Service
public class LicenseService {

    private final MessageSource message;

    public License getLicense(String licenseId, String organizationId) {
        License license = new License();
        license.setId(new Random().nextInt(1000));
        license.setLicenseId(licenseId);
        license.setOrganizationId(organizationId);
        license.setDescription("Software product");
        license.setProductName("Ostock");
        license.setLicenseType("full");
        return license;
    }

    // Recibe la configuración regional (Locale) como parámetro del método.
    public String createLicense(License license, String organizationId, Locale locale) {
        String responseMessage = null;
        if (license != null) {
            license.setOrganizationId(organizationId);

            // Establece la configuración regional (Locale) recibida para recuperar el mensaje específico.
            responseMessage = this.message.getMessage("license.create.message", null, locale)
                    .formatted(license.toString());
        }
        return responseMessage;
    }

    public String updateLicense(License license, String organizationId) {
        String responseMessage = null;
        if (license != null) {
            license.setOrganizationId(organizationId);

            // Envía una configuración regional (Locale) para recuperar el mensaje específico.
            responseMessage = this.message.getMessage("license.update.message", null, LocaleContextHolder.getLocale())
                    .formatted(license.toString());
        }
        return responseMessage;
    }

    public String deleteLicense(String licenseId, String organizationId) {
        // Envía una configuración regional (Locale) para recuperar el mensaje específico.
        return this.message.getMessage("license.delete.message", null, LocaleContextHolder.getLocale())
                .formatted(licenseId, organizationId);
    }

}
````

Hay tres cosas importantes a resaltar del código anterior. La primera es que podemos recibir la configuración
regional (Locale) desde el propio controlador. La segunda es que podemos llamar
a `message.getMessage("license.create.message",null,locale)` usando la configuración regional que recibimos por
parámetros, y la tercera cosa a tener en cuenta es que
podemos llamar a `message.getMessage("license.update.message", null, LocaleContextHolder.getLocale())` enviándole la
configuración regional que establecimos por defecto.

`LocaleContextHolder.getLocale()`, devuelve la configuración regional (Locale) asociada con el hilo actual, si la hay,
o la configuración regional predeterminada del sistema en caso contrario. Esto es efectivamente un reemplazo de
`Locale.getDefault()`, capaz de respetar opcionalmente una configuración regional a nivel de usuario.

**Nota:** Este método tiene un respaldo a la configuración regional predeterminada compartida, ya sea a nivel de marco
o a nivel de sistema en todo `JVM`. Si desea verificar el contenido `localeContext` sin formato
(que puede indicar que no hay una configuración regional específica a través de null, use `getLocaleContext()` y
llame a `LocaleContext.getLocale()`.

`LocaleContextHolder.getLocale()`, devuelve la configuración regional actual, o la configuración regional
predeterminada del sistema si no se ha asociado ninguna configuración regional específica con el hilo actual.

Ahora actualicemos nuestro método `createLicense()` en el controlador para recibir el idioma en el
encabezado (`Accept-Language`) de la solicitud con este código:

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/v1/organization/{organizationId}/license")
public class LicenseController {

    private final LicenseService licenseService;

    /* other methods */

    @PostMapping
    public ResponseEntity<String> createLicense(@PathVariable String organizationId,
                                                @RequestBody License license,
                                                @RequestHeader(value = "Accept-Language", required = false) Locale locale) {
        return ResponseEntity.ok(this.licenseService.createLicense(license, organizationId, locale));
    }

    /* another method */
}
````

Algunas cosas a tener en cuenta en el código anterior es que aquí usamos la anotación `@RequestHeader`. La
anotación `@RequestHeader` asigna los parámetros del método con los valores del encabezado de la solicitud. En el
método `createLicense()`, recuperamos la configuración regional (Locale) del encabezado de solicitud `Accept-Language`.
Este parámetro de servicio no es obligatorio, por lo que si no se especifica, usaremos la configuración regional
predeterminada.

**NOTA**
> No existe una regla bien definida sobre cómo utilizar la configuración regional. Nuestra recomendación es analizar tu
> arquitectura y seleccionar la opción que más te convenga. Por ejemplo, si la aplicación de front-end maneja la
> configuración regional, la mejor opción es recibir la configuración regional como parámetro en el método del
> controlador. Pero si administra la configuración regional en el backend, puede usar una configuración regional
> predeterminada.

## Probando la configuración Locale

Enviando la configuración en `en` para obtener los mensajes en inglés a través de la cabecera http `Accept-Language`:

````bash
$ curl -v -X POST -H "Content-Type: application/json" -H "Accept-Language: en" -d "{\"licenseId\": \"0235454846\", \"description\": \"Software product\", \"productName\": \"Teclado\", \"licenseType\": \"full\"}" http://localhost:8080/v1/organization/optimaGrowth/license
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 166
< Date: Fri, 03 May 2024 01:13:58 GMT
<
License created License(id=null, licenseId=0235454846, description=Software product, organizationId=optimaGrowth, productName=Teclado, licenseType=full) successfully!
````

Enviando la configuración en `es` para obtener los mensajes en español a través de la cabecera http `Accept-Language`:

````bash
$ curl -v -X POST -H "Content-Type: application/json" -H "Accept-Language: es" -d "{\"licenseId\": \"0235454846\", \"description\": \"Software product\", \"productName\": \"Teclado\", \"licenseType\": \"full\"}" http://localhost:8080/v1/organization/optimaGrowth/license
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 166
< Date: Fri, 03 May 2024 01:14:29 GMT
<
¡Licencia creada License(id=null, licenseId=0235454846, description=Software product, organizationId=optimaGrowth, productName=Teclado, licenseType=full) con éxito!
````

En esta prueba llamaremos al endpoint de actualización. En esta prueba no le vamos a mandar la configuración del Locale
por cabecera, dado que el método de actualizar del controlador no está esperando ningún Locale, por lo que el método
`updateLicense()` de la clase de servicio usa el `LocaleContextHolder.getLocale()` para obtener el Locale que definimos
por defecto. Por lo tanto, la configuración que se aplicará será el que definimos por defecto, es decir el idioma en
español.

````bash
$ curl -v -X PUT -H "Content-Type: application/json" -d "{\"licenseId\": \"0235454846\", \"description\": \"Software product\", \"productName\": \"Teclado\", \"licenseType\": \"full\"}" http://localhost:8080/v1/organization/optimaGrowth/license
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 169
< Date: Fri, 03 May 2024 01:16:40 GMT
<
Licencia License(id=null, licenseId=0235454846, description=Software product, organizationId=optimaGrowth, productName=Teclado, licenseType=full) actualizada con éxito!
````

Por último, llamaremos al endpoint de eliminar. Esta prueba nos debe devolver el código asociado al
mensaje `license.delete.message`, dado que no tenemos dicha configuración en ningún archivo. El comportamiento por
defecto sería lanzar un error, pero como agregamos la configuración `messageSource.setUseCodeAsDefaultMessage(true)`,
en el bean `ResourceBundleMessageSource`, eso nos permite mostrar la clave usada en lugar de lanzar el error.

````bash
$ curl -v -X DELETE http://localhost:8080/v1/organization/optimaGrowth/license/0235431845
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 22
< Date: Fri, 03 May 2024 01:19:18 GMT
<
license.delete.message
````

## 3. Implementar Spring HATEOAS para proporcionar suficiente información para que el usuario pueda interactuar con el servidor

`HATEOAS significa Hipermedia como motor de estado de aplicación`. Spring HATEOAS es un pequeño proyecto que nos permite
crear API que siguen el principio HATEOAS de mostrar los enlaces relacionados para un recurso determinado. El principio
HATEOAS establece que una API debe proporcionar una guía al cliente devolviendo información sobre los posibles próximos
pasos con cada respuesta de servicio. Este proyecto no es una característica básica ni imprescindible, pero si desea
tener una guía completa para todos los servicios API de un recurso determinado, es una excelente opción.

Con Spring HATEOAS, puede crear rápidamente clases de modelos para enlaces a modelos de representación de recursos.
También proporciona una API de creación de enlaces para crear enlaces específicos que apuntan a métodos del controlador
Spring MVC.

`Spring HATEOAS`, facilita la creación de `API RESTful` que siguen el principio `HATEOAS` cuando se trabaja con
`Spring/Spring MVC`.

En esta sección, le mostraremos cómo implementar `Spring HATEOAS` en el servicio de licencia. Lo primero que debemos
hacer para enviar los enlaces relacionados a un recurso en la respuesta, es agregar la dependencia HATEOAS a nuestro
archivo `pom.xml`, así:

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
````

Una vez que tenemos la dependencia, necesitamos actualizar la clase `License` para poder extenderla desde
`RepresentationModel<License>`. La siguiente lista muestra cómo hacer esto.

````java

@ToString
@Getter
@Setter
public class License extends RepresentationModel<License> {
    private Integer id;
    private String licenseId;
    private String description;
    private String organizationId;
    private String productName;
    private String licenseType;
}
````

`RepresentationModel<License>` nos brinda la posibilidad de agregar enlaces a la clase de modelo `License`. Ahora que
tenemos todo configurado, creemos la configuración de `HATEOS` para recuperar los enlaces de la
clase `LicenseController`. La siguiente lista muestra cómo se hace esto. Para este ejemplo, solo cambiaremos el método
`getLicense()` en la clase `LicenseController`.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/v1/organization/{organizationId}/license")
public class LicenseController {

    private final LicenseService licenseService;

    @GetMapping(path = "/{licenseId}")
    public ResponseEntity<License> getLicense(@PathVariable String organizationId, @PathVariable String licenseId) {
        License license = this.licenseService.getLicense(licenseId, organizationId);

        license.add(WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(LicenseController.class)
                                .getLicense(organizationId, license.getLicenseId()))
                        .withSelfRel(),
                WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(LicenseController.class)
                                .createLicense(organizationId, license, LocaleContextHolder.getLocale()))
                        .withRel("createLicense"),
                WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(LicenseController.class)
                                .updateLicense(organizationId, license))
                        .withRel("updateLicense"),
                WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(LicenseController.class)
                                .deleteLicense(organizationId, license.getLicenseId()))
                        .withRel("deleteLicense"));

        return ResponseEntity.ok(license);
    }
    /* another methods */
}
````

El método `add()` es un método de `RepresentationModel`. El método `linkTo` inspecciona la clase de controlador de
licencia y obtiene la asignación raíz, y el método `methodOn` obtiene la asignación del método realizando una invocación
ficticia del método de destino. Ambos métodos son métodos estáticos
de `org.springframework.hateoas.server.mvc.WebMvcLinkBuilder` es una clase de utilidad para crear enlaces en las clases
de controlador. La siguiente llamada http muestra los enlaces en el cuerpo de respuesta del servicio `getLicense()`.
Para recuperarlos, debe llamar al método GET HTTP.

````bash
$ curl -v http://localhost:8080/v1/organization/optimaGrowth/license/0235431845 | jq
<
< HTTP/1.1 200
< Content-Type: application/hal+json
< Transfer-Encoding: chunked
< Date: Fri, 03 May 2024 03:33:35 GMT
<
{
  "id": 702,
  "licenseId": "0235431845",
  "description": "Software product",
  "organizationId": "optimaGrowth",
  "productName": "Ostock",
  "licenseType": "full",
  "_links": {
    "self": {
      "href": "http://localhost:8080/v1/organization/optimaGrowth/license/0235431845"
    },
    "createLicense": {
      "href": "http://localhost:8080/v1/organization/optimaGrowth/license"
    },
    "updateLicense": {
      "href": "http://localhost:8080/v1/organization/optimaGrowth/license"
    },
    "deleteLicense": {
      "href": "http://localhost:8080/v1/organization/optimaGrowth/license/0235431845"
    }
  }
}
````

En este punto, tiene el esqueleto de un servicio en ejecución. Pero desde una perspectiva de desarrollo, este servicio
no está completo. Un buen diseño de microservicio no evita segregar el servicio en capas de acceso a datos y lógica
empresarial bien definidas. A medida que avance en capítulos posteriores, continuará repitiendo este servicio y
profundizando en cómo estructurarlo. Por ahora, pasemos a la perspectiva final: explorar cómo un ingeniero de DevOps
pondría en funcionamiento el servicio y lo empaquetaría para su implementación en la nube.

## La historia del DevOps: construcción para los rigores del tiempo de ejecución

Si bien DevOps es un campo de TI rico y emergente, para el ingeniero de DevOps, el diseño del microservicio tiene que
ver con la gestión del servicio después de que entra en producción. Escribir el código suele ser la parte fácil.
Mantenerlo funcionando es la parte difícil. Comenzaremos nuestro esfuerzo de desarrollo de microservicios con cuatro
principios y los desarrollaremos más adelante en el libro:

- `Un microservicio debe ser autónomo`. También debería poder implementarse de forma independiente con múltiples
  instancias del servicio iniciadas y desmanteladas con un único artefacto de software.


- `Un microservicio debe ser configurable`. Cuando se inicia una instancia de servicio, debe leer los datos que necesita
  para configurarse desde una ubicación central o transmitir su información de configuración como variables de entorno.
  No debería ser necesaria ninguna intervención humana para configurar el servicio.


- `Una instancia de microservicio debe ser transparente para el cliente`. El cliente nunca debe saber la ubicación
  exacta de un servicio. En cambio, un cliente de microservicio debería hablar con un agente de descubrimiento de
  servicios. Eso permite que la aplicación ubique una instancia de un microservicio sin tener que conocer su ubicación
  física.


- `Un microservicio debe comunicar su estado`. Esta es una parte fundamental de su arquitectura en la nube. Las
  instancias de microservicio fallarán y los agentes de descubrimiento deberán evitar las instancias de servicio
  incorrectas. En este libro, usaremos `Spring Boot Actuator` para mostrar el estado de cada microservicio.

Estos cuatro principios exponen la paradoja que puede existir con el desarrollo de microservicios. Los microservicios
son más pequeños en tamaño y alcance, pero su uso introduce más partes móviles en una aplicación porque los
microservicios se distribuyen y ejecutan de forma independiente unos de otros en sus propios contenedores. Esto
introduce un alto grado de coordinación y más oportunidades de puntos de falla en la aplicación.

Desde una perspectiva de `DevOps`, debe abordar las necesidades operativas de un microservicio desde el principio y
traducir estos cuatro principios en un conjunto estándar de eventos del ciclo de vida que ocurren cada vez que se
construye e implementa un microservicio en un entorno. Los cuatro principios se pueden asignar a los siguientes ciclos
de vida operativos. La figura 3.9 muestra cómo encajan estos cuatro pasos.

- `Montaje del servicio`: cómo empaqueta e implementa su servicio para garantizar la repetibilidad y la coherencia, de
  modo que el mismo código de servicio y tiempo de ejecución se implementen exactamente de la misma manera.

- `Arranque del servicio`: cómo separar el código de configuración específico de su aplicación y entorno del código de
  tiempo de ejecución para que pueda iniciar e implementar una instancia de microservicio rápidamente en cualquier
  entorno sin intervención humana.

- `Registro/descubrimiento de servicio`: cuando se implementa una nueva instancia de microservicio, cómo hacer que la
  nueva instancia de servicio sea detectable por otros clientes de aplicaciones.

- `Monitoreo de servicios`: en un entorno de microservicios, es común que se ejecuten varias instancias del mismo
  servicio debido a necesidades de alta disponibilidad. Desde una perspectiva de DevOps, es necesario monitorear las
  instancias de microservicios y asegurarse de que cualquier falla se direccione alrededor de las instancias de servicio
  fallidas y que se eliminen.

![12.devops-history.png](./assets/12.devops-history.png)

## Montaje de servicios: empaquetar e implementar sus microservicios

Desde una perspectiva de DevOps, uno de los conceptos clave detrás de una arquitectura de microservicio es que se pueden
implementar rápidamente múltiples instancias de un microservicio en respuesta a un entorno de aplicación modificado (por
ejemplo, una afluencia repentina de solicitudes de usuarios, problemas dentro de la infraestructura, etc.). en). Para
lograr esto, un microservicio debe empaquetarse e instalarse como un único artefacto con todas sus dependencias
definidas en él. Estas dependencias también deben incluir el motor de tiempo de ejecución (por ejemplo, un servidor HTTP
o un contenedor de aplicaciones) que aloja el microservicio.

Afortunadamente, casi todos los marcos de microservicios de Java incluirán un motor de tiempo de ejecución que puede
empaquetar e implementar con el código. Por ejemplo, en el ejemplo de Spring Boot en la figura 3.10, Maven y Spring Boot
crean un archivo JAR Java ejecutable que tiene un motor Tomcat integrado directamente en el JAR. **En el siguiente
ejemplo de línea de comandos, creamos el servicio de licencias como un JAR ejecutable y luego iniciamos el JAR desde la
línea de comandos:**

````bash
$ mvn clean package && java -jar target/licensing-service-0.0.1-SNAPSHOT.jar
````

Para ciertos equipos de operaciones, el concepto de incorporar un entorno de ejecución directamente en el archivo JAR es
un cambio importante en su forma de pensar acerca de la implementación de aplicaciones. En una aplicación web
tradicional Java, la aplicación se implementa en un servidor de aplicaciones. Este modelo implica que el servidor de
aplicaciones es una entidad en sí misma y, a menudo, sería administrado por un equipo de administradores de sistemas que
supervisan la configuración del servidor independientemente de las aplicaciones que se les implementen.

Esta separación de la configuración del servidor de aplicaciones de la aplicación introduce puntos de falla en el
proceso de implementación. Esto se debe a que, en muchas organizaciones, la configuración de los servidores de
aplicaciones no se mantiene bajo control de origen y se administra mediante una combinación de interfaz de usuario y
scripts de administración locales. Es demasiado fácil que la deriva de la configuración se introduzca en el entorno del
servidor de aplicaciones y provoque repentinamente lo que en la superficie parecen ser interrupciones aleatorias.

## Arranque de servicios: gestión de la configuración de sus microservicios

El arranque del servicio (paso 2 en la figura 3.9) ocurre cuando el microservicio se inicia por primera vez y necesita
cargar la información de configuración de su aplicación.

Como sabe cualquier desarrollador de aplicaciones, habrá ocasiones en las que será necesario configurar el
comportamiento en tiempo de ejecución de la aplicación. Por lo general, esto implica leer los datos de configuración de
su aplicación desde un archivo de propiedades implementado con la aplicación o leer los datos de un almacén de datos
como una base de datos relacional.

Los microservicios suelen encontrarse con el mismo tipo de requisitos de configuración. La diferencia es que en una
aplicación de microservicio que se ejecuta en la nube, es posible que tenga cientos o incluso miles de instancias de
microservicio en ejecución. Para complicar aún más esto, los servicios podrían extenderse por todo el mundo. Con una
gran cantidad de servicios dispersos geográficamente, resulta inviable volver a implementar sus servicios para recoger
nuevos datos de configuración. Almacenar los datos en un almacén de datos externo al servicio resuelve este problema.
Pero los microservicios en la nube ofrecen una serie de desafíos únicos:

- Los datos de configuración tienden a tener una estructura simple y generalmente se leen con frecuencia y se escriben
  con poca frecuencia. Las bases de datos relacionales son excesivas en esta situación porque están diseñadas para
  gestionar modelos de datos mucho más complicados que un simple conjunto de pares clave-valor.


- Debido a que se accede a los datos de forma regular pero cambian con poca frecuencia, los datos deben poder leerse con
  un nivel bajo de latencia.


- El almacén de datos debe tener alta disponibilidad y estar cerca de los servicios que leen los datos. Un almacén de
  datos de configuración no puede dejar de funcionar por completo porque se convertiría en un punto único de falla para
  su aplicación.

En el capítulo 5, mostraremos cómo administrar los datos de configuración de su aplicación de microservicio utilizando
elementos como un simple almacén de datos de valores-clave.

## Registro y descubrimiento de servicios: cómo se comunican los clientes con sus microservicios

Desde la perspectiva del consumidor de microservicios, un microservicio debe ser transparente en cuanto a ubicación
porque en un entorno basado en la nube, los servidores son efímeros. Efímero significa que los servidores en los que se
aloja un servicio suelen tener una vida más corta que un servicio que se ejecuta en un centro de datos corporativo. Los
servicios basados `Ephemeral` la nube se pueden iniciar y desactivar rápidamente con una dirección IP completamente
nueva asignada al servidor en el que se ejecutan los servicios.

Al insistir en que los servicios se traten como objetos desechables de corta duración, las arquitecturas de
microservicios pueden lograr un alto grado de escalabilidad y disponibilidad al tener múltiples instancias de un
servicio en ejecución. La demanda del servicio y la resiliencia se pueden gestionar tan rápido como la situación lo
amerite. Cada servicio tiene asignada una dirección IP única y no permanente. La desventaja de los servicios efímeros es
que, dado que los servicios suben y bajan constantemente, administrar un gran conjunto de estos servicios manualmente
es una invitación a una interrupción.

Una instancia de microservicio debe registrarse con un agente externo. Este proceso de registro se denomina
descubrimiento de servicios (consulte el paso 3 en la figura 3.9). Cuando una instancia de microservicio se registra con
un agente de descubrimiento de servicios, le dice al agente de descubrimiento dos cosas: **la dirección IP física (o
dirección de dominio de la instancia de servicio) y un nombre lógico que una aplicación puede usar para buscar el
servicio.** Ciertos agentes de descubrimiento de servicios también requieren que se envíe una URL al servicio de
registro, que el agente de descubrimiento de servicios puede utilizar para realizar comprobaciones de estado. Luego, el
cliente del servicio se comunica con el agente de descubrimiento para buscar la ubicación del servicio.

## Comunicar el estado de un microservicio

Un agente de descubrimiento de servicios no actúa sólo como un policía de tráfico que guía al cliente hasta la ubicación
del servicio. En una aplicación de microservicio basada en la nube, a menudo tendrá varias instancias de un servicio en
ejecución. Tarde o temprano, una de esas instancias de servicio fallará. El agente de descubrimiento de servicios
monitorea el estado de cada instancia de servicio registrada con él y elimina cualquier instancia de servicio fallida de
sus tablas de enrutamiento para garantizar que no se envíe a los clientes una instancia de servicio que haya fallado.

Después de que aparece un microservicio, el agente de descubrimiento de servicios continuará monitoreando y haciendo
ping a la interfaz de verificación de estado para garantizar que ese servicio esté disponible. Este es el paso 4 en la
figura 3.9.

Al crear una interfaz de verificación de estado consistente, puede utilizar herramientas de monitoreo basadas en la nube
para detectar problemas y responder a ellos de manera adecuada. Si el agente de descubrimiento de servicios descubre un
problema con una instancia de servicio, puede tomar medidas correctivas, como cerrar la instancia defectuosa o activar
instancias de servicio adicionales.

En un entorno de microservicio que utiliza REST, la forma más sencilla de crear una interfaz de verificación de estado
es exponer un punto final HTTP que pueda devolver una carga útil JSON y un código de estado HTTP. En un microservicio
que no está basado en Spring Boot, a menudo es responsabilidad del desarrollador escribir un punto final que devuelva el
estado del servicio.

En Spring Boot, exponer un punto final es trivial e implica nada más que modificar su archivo de compilación Maven para
incluir el módulo `Spring Actuator`. `Spring Actuator` proporciona puntos finales operativos listos para usar que lo
ayudan a comprender y administrar el estado de su servicio. Para utilizar `Spring Actuator`, debe incluir las siguientes
dependencias en su archivo de compilación de Maven:

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
````

Si llega al punto final `http://localhost:8080/actuator/health` en el servicio de licencias, debería ver los datos de
estado devueltos. También puede brindar información sobre el estado del servidor en el que se ejecuta la instancia del
microservicio. `Spring Actuator` le permite cambiar la configuración predeterminada a través del archivo de propiedades
de
la aplicación. Por ejemplo:

````yaml
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
  health:
    diskspace:
      enabled: true
  info:
    env:
      enabled: true
    build:
      enabled: true
    git:
      enabled: true
      mode: full
    java:
      enabled: true
    os:
      enabled: true
````

````bash
$ curl -v http://localhost:8080/actuator/health | jq
>
< HTTP/1.1 200
< Content-Type: application/vnd.spring-boot.actuator.v3+json
< Transfer-Encoding: chunked
< Date: Fri, 03 May 2024 04:19:43 GMT
<
{
  "status": "UP",
  "components": {
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 240053645312,
        "free": 97453420544,
        "threshold": 10485760,
        "path": "M:\\PROGRAMACION\\DESARROLLO_JAVA_SPRING\\08.book_ms-in-action-2021\\spring-microservices-in-action-2021\\.",
        "exists": true
      }
    },
    "ping": {
      "status": "UP"
    }
  }
}
````