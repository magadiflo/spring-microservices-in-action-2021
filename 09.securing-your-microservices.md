# Protegiendo tus microservicios

Pág. 240

---

Ahora que contamos con una arquitectura de microservicios robusta, la tarea de cubrir las vulnerabilidades de seguridad
se vuelve cada vez más esencial. En este capítulo, la seguridad y la vulnerabilidad van de la mano. **Definiremos
`vulnerabilidad` como una debilidad o falla presentada en una aplicación.** Por supuesto, todos los sistemas tienen
vulnerabilidades, pero la gran diferencia radica en si estas vulnerabilidades se explotan y causan daño.

Mencionar la seguridad a menudo provoca un gemido involuntario por parte de los desarrolladores. Entre los
desarrolladores escuchamos comentarios como: "Es obtuso, difícil de entender y aún más difícil de depurar". Sin embargo,
no encontraremos ningún desarrollador (excepto quizás un desarrollador sin experiencia) que diga que no se preocupa por
la seguridad. Proteger una arquitectura de microservicios es una tarea compleja y laboriosa que implica múltiples capas
de protección, incluidas las siguientes:

- `La capa de aplicación`: garantiza que existan los controles de usuario adecuados para que podamos validar que un
  usuario es quien dice ser y que tiene permiso para hacer lo que está intentando hacer.
- `Infraestructura`: mantiene el servicio en funcionamiento, parcheado y actualizado para minimizar el riesgo de
  vulnerabilidades.
- `Una capa de red`: implementa controles de acceso a la red para que solo se pueda acceder a un servicio a través de
  puertos bien definidos y solo para una pequeña cantidad de servidores autorizados.

Este capítulo solo cubre cómo autenticar y autorizar usuarios en nuestra `capa de aplicación` (el primer punto de la
lista). Los otros dos elementos son temas de seguridad extremadamente amplios que están fuera del alcance de este libro.
Además, existen otras herramientas, como el Proyecto OWASP Dependency-Check, que pueden ayudar a identificar
vulnerabilidades.

Para implementar controles de autorización y autenticación, usaremos el módulo `Spring Cloud Security` y `Keycloak` para
proteger nuestros servicios basados en Spring. `Keycloak` es un software de gestión de acceso e identidad de código
abierto para aplicaciones y servicios modernos. Este software de código abierto está escrito en Java y admite protocolos
de identidad federados SAML (Security Assertion Markup Language) v2 y OpenID Connect (OIDC)/OAuth2.

## 9.1 ¿Qué es OAuth2?

`OAuth2` es un marco de seguridad basado en tokens que describe patrones para otorgar autorización pero no define cómo
realizar realmente la autenticación. En cambio, permite a los usuarios autenticarse con un servicio de autenticación de
terceros, llamado `proveedor de identidad (IdP)`. Si el usuario se autentica correctamente, se le presenta un token que
debe enviarse con cada solicitud. Luego, el token se puede volver a validar en el servicio de autenticación.

El objetivo principal detrás de `OAuth2` es que cuando se llaman varios servicios para cumplir con la solicitud de un
usuario, cada servicio puede autenticar al usuario sin tener que presentar sus credenciales a cada servicio que procese
su solicitud. `OAuth2` nos permite proteger nuestros servicios basados en REST en diferentes escenarios mediante
esquemas de autenticación llamados concesiones `(grants)`. La especificación `OAuth2` tiene cuatro tipos de concesiones:

- Password
- Client credentials
- Authorization code
- Implicit

**NOTA**
> Actualmente `Implicit` y el `Password` son concesiones legacy, mientras que hay otras que han surgido como el
> `PKCE` que es similar al `Authorization Code`. Para más información visitar mi repositorio de
> [spring-security-in-action-2020](https://github.com/magadiflo/spring-security-in-action-2020/blob/main/12.1.oauth2_y_open-id-connect.md)

No vamos a analizar cada uno de estos tipos de subvenciones ni a proporcionar ejemplos de código para cada uno. Es
demasiado material para cubrirlo en un solo capítulo. En su lugar, haremos lo siguiente:

- Analice cómo nuestros microservicios pueden usar OAuth2 a través de uno de los tipos de concesión de OAuth2 más
  simples, el tipo de concesión de password.
- Utilice tokens web JSON (JWT) para proporcionar una solución OAuth2 más sólida y establecer un estándar para codificar
  información en un token OAuth2.
- Analice otras consideraciones de seguridad que deben tenerse en cuenta al crear microservicios.

**NOTA**
> Proporcionamos una descripción general de los otros tipos de concesiones de OAuth2 en el apéndice B. Si está
> interesado en profundizar en más detalles sobre la especificación de OAuth2 y cómo implementar todos los tipos de
> concesiones, le recomendamos encarecidamente el libro de Justin Richer y Antonio Sanso, OAuth2 en Action (Manning,
> 2017), que es una explicación completa de OAuth2.

El verdadero poder detrás de `OAuth2` es que permite a los desarrolladores de aplicaciones integrarse fácilmente con
proveedores de nube externos y autenticar y autorizar a los usuarios con esos servicios sin tener que pasar las
credenciales del usuario continuamente al servicio de terceros.

`OpenID Connect (OIDC)` es una capa encima del marco OAuth2 que proporciona autenticación e información de perfil sobre
quién ha iniciado sesión en la aplicación (la identidad). Cuando un servidor de autorización admite OIDC, a veces se le
denomina proveedor de identidad. Antes de entrar en los detalles técnicos de la protección de nuestros servicios,
repasemos la arquitectura de `Keycloak`.

## 9.2 Introducción a Keycloak

`Keycloak` es una solución de gestión de acceso e identidad de código abierto para nuestros servicios y aplicaciones. El
principal objetivo de Keycloak es facilitar la protección de los servicios y aplicaciones con poco o ningún código.
Algunas características de Keycloak incluyen las siguientes:

- Centraliza la autenticación y permite la autenticación de inicio de sesión único (SSO).
- Permite a los desarrolladores centrarse en la funcionalidad empresarial en lugar de preocuparse por aspectos de
  seguridad como la autorización y la autenticación.
- Permite la autenticación de dos factores.
- Es compatible con LDAP.
- Ofrece varios adaptadores para proteger aplicaciones y servidores fácilmente.
- Le permite personalizar las políticas de contraseñas.

![53.flow-keycloak.png](./assets/53.flow-keycloak.png)

La seguridad de `Keycloak` se puede dividir en estos cuatro componentes: recurso protegido, propietario del recurso,
aplicación y servidor de autenticación/autorización. La `figura 9.1` muestra cómo interactúan los cuatro componentes.

- `Un recurso protegido`: el recurso (en nuestro caso, un microservicio) que desea proteger, garantizando que solo los
  usuarios autenticados que tengan la autorización adecuada puedan acceder a él.


- `Un propietario de recurso`: este propietario define qué aplicaciones pueden llamar al servicio, qué usuarios tienen
  acceso al servicio y qué pueden hacer los usuarios con el servicio. Cada aplicación registrada por el propietario del
  recurso recibe un nombre de aplicación que la identifica, junto con una clave secreta. La combinación del nombre de la
  aplicación y la clave secreta son parte de las credenciales que se pasan al autenticar un token de acceso.


- `Una aplicación`: esta es la aplicación que llamará al servicio en nombre de un usuario. Después de todo, los usuarios
  rara vez invocan un servicio directamente. En cambio, dependen de una aplicación para que haga el trabajo por ellos.


- `Servidor de autenticación/autorización`: el servidor de autenticación es el intermediario entre la aplicación y los
  servicios que se consumen. El servidor de autenticación permite al usuario autenticarse sin tener que pasar sus
  credenciales de usuario a cada servicio que la aplicación llamará en su nombre.

Como se mencionó anteriormente, los componentes de seguridad de `Keycloak` interactúan entre sí para autenticar a los
usuarios del servicio. Los usuarios se autentican en el servidor Keycloak proporcionando sus credenciales y la
aplicación/dispositivo que están utilizando para acceder a un recurso protegido (el microservicio). Si las credenciales
de los usuarios son válidas, el servidor Keycloak proporciona un token de autenticación que se puede pasar de un
servicio a otro cada vez que los usuarios utilizan un servicio.

Luego, el recurso protegido puede comunicarse con el servidor Keycloak para determinar la validez del token y recuperar
los roles asignados para un usuario. Los roles se utilizan para agrupar usuarios relacionados y definir a qué recursos
pueden acceder. En este capítulo, usaremos roles de Keycloak para determinar qué verbos HTTP puede usar un usuario para
llamar a qué puntos finales de servicio autorizados.

La seguridad de los servicios web es un tema extremadamente complicado. Necesitamos comprender quién llamará a nuestros
servicios (usuarios internos o usuarios externos), cómo llamarán a nuestro servicio (cliente web interno, dispositivo
móvil o aplicación web) y qué acciones realizarán con nuestro código.

**Sobre autenticación vs autorización**

> A menudo hemos descubierto que los desarrolladores "mezclan y combinan" el significado de los términos `autenticación`
> y `autorización`. La `autenticación` es el acto de un usuario que demuestra quién es proporcionando credenciales.
> La `autorización` determina si un usuario puede hacer lo que quiere hacer. Por ejemplo, la usuaria Illary podría
> demostrar su identidad proporcionando un ID de usuario y una contraseña, pero es posible que no esté autorizada a
> consultar datos confidenciales (datos de nómina, por ejemplo). Para nuestra discusión, un usuario debe autenticarse
> antes de que se realice la autorización.

## 9.3 Empezando poco a poco: usando Spring y Keycloak para proteger un único endpoint

Para comprender cómo configurar las piezas de autenticación y autorización, haremos lo siguiente:

- Agregue un servicio Keycloak a Docker.
- Configure un servicio Keycloak y registre la aplicación O-stock como una aplicación autorizada que puede autenticar y
  autorizar identidades de usuarios.
- Utilice Spring Security para proteger nuestros servicios O-stock. No vamos a crear una interfaz de usuario para
  O-stock; en su lugar, simularemos un usuario que inicia sesión en Postman para proporcionar autenticación para nuestro
  servicio Keycloak.
- Proteger los servicios de organización y licencias para que solo puedan ser llamados por un usuario autenticado.

## [Agregando Keycloak a Docker](https://www.keycloak.org/getting-started/getting-started-docker)

Esta sección explica cómo agregar el servicio `Keycloak` a nuestro entorno `Docker`. Para lograr esto, trabajaremos
con docker compose, por lo tanto, crearemos el directorio `/docker` y dentro de él el archivo `compose.yml`,
ahora, agregaremos las siguientes configuraciones en nuestro archivo `/docker/compose.yml`:

````yml
services:
  postgres_for_keycloak:
    image: postgres:15.2-alpine
    container_name: c-postgres-for-keycloak
    restart: unless-stopped
    environment:
      POSTGRES_DB: db_keycloak
      POSTGRES_USER: magadiflo
      POSTGRES_PASSWORD: magadiflo
    ports:
      - 5435:5432
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [ 'CMD-SHELL', 'pg_isready -U magadiflo -d db_keycloak' ]
      interval: 10s
      timeout: 5s
      retries: 5

  keycloak:
    image: quay.io/keycloak/keycloak:21.0.2
    container_name: c-keycloak
    restart: unless-stopped
    command:
      - 'start-dev'
    ports:
      - 8181:8080
    depends_on:
      postgres_for_keycloak:
        condition: service_healthy
    environment:
      KC_DB: postgres
      KC_DB_URL_HOST: postgres_for_keycloak
      KC_DB_URL_DATABASE: db_keycloak
      KC_DB_USERNAME: magadiflo
      KC_DB_PASSWORD: magadiflo
      KC_DB_SCHEMA: public
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin

volumes:
  postgres_data:
    name: postgres_data
````

Observemos que en las configuraciones anteriores estamos definiendo un contenedor para `Keycloak` y además un
contenedor de base de datos para `Postgres` que usará `Keycloak`. Ahora, **¿cómo podemos esperar a que el contenedor
de postgres se inicie correctamente y esté en buen estado para recién iniciar los contenedores que de él dependen?**
La opción más básica es usar la directiva `depends_on`, que te permite indicar que tu contenedor de keycloak debe
iniciarse después de tu base de datos, ya que depende de ella:

````yml
depends_on:
  - postgres_for_keycloak
````

Si bien esto está bien, en realidad no es suficiente en la mayoría de los casos: el contenedor de keycloak solo esperará
a que se ejecute el contenedor de la base de datos, **¡pero eso no significa que la base de datos aún se haya
iniciado!.** Entonces, para mejorar esa dependencia de servicios, podemos usar la
opción `healthcheck (checkeo de salud)`. Es un mecanismo simple y eficiente para saber si un contenedor está en buen
estado o no.

La siguiente verificación de estado `(healthcheck`) se ha configurado para verificar periódicamente si PostgreSQL está
listo, para ello usamos el comando [pg_isready](https://www.postgresql.org/docs/9.4/app-pg-isready.html), que es
un comando del mismo Postgres.

````yml
healthcheck:
  test: [ 'CMD-SHELL', 'pg_isready -U magadiflo -d db_keycloak' ]
  interval: 10s
  timeout: 5s
  retries: 5
````

Detallemos el comando anterior:

- `test`: Indica el comando que se ejecutará para verificar la salud del contenedor.
    - `CMD-SHELL`: Especifica que se utilizará un comando de shell para la verificación de salud.
    - `pg_isready -U magadiflo -d db_keycloak`: Este comando específico se utiliza para comprobar si el servidor de
      PostgreSQL está listo para aceptar conexiones en la base de datos `db_keycloak` con el usuario `magadiflo`.

- `interval`: Indica el intervalo de tiempo en segundos entre cada ejecución del comando de verificación de salud. En
  este caso, se ejecutará cada 5 segundos.

- `timeout`: Especifica el tiempo máximo en segundos que Docker esperará para que el comando de verificación de salud
  se complete antes de considerarlo como un fallo. Aquí se ha configurado en 5 segundos.
  retries: 5:

- `retries`: Indica el número de intentos que Docker realizará para verificar la salud del contenedor antes de
  considerarlo como un fallo. En tu caso, se han configurado 5 intentos.

En resumen, estas configuraciones definen cómo Docker Compose verificará la salud del contenedor de PostgreSQL
utilizando un comando de shell específico, con un intervalo de 5 segundos entre cada verificación, un tiempo máximo de
espera de 5 segundos para cada verificación y un límite de 5 intentos de verificación antes de considerar que el
contenedor no está saludable.

Una última configuración que es importante resaltar es el que definimos en el servicio de `keycloak`:

````yml
depends_on:
  postgres_for_keycloak:
    condition: service_healthy
````

La configuración anterior indica que el contenedor de keycloak depende del contenedor de postgres, pero la condición
para que el contenedor de keycloak se inicie es que el servicio de postgres debe estar saludable `(service_healthy)`.

**NOTA**
> Puede utilizar Keycloak con varias bases de datos como H2, PostgreSQL, MySQL, Microsoft SQL Server, Oracle y MariaDB.
> Para configurar una base de datos relacional con `Keycloak` visite el siguiente enlace:
> https://www.keycloak.org/server/db


Para que `Keycloak` funcione en nuestro entorno local, necesitamos agregar la entrada de host `127.0.0.1 Keycloak` a
nuestro archivo de `hosts`. Si está utilizando Windows, debe agregar la entrada de host en
`C:\Windows\System32\drivers\etc\hosts`, y si está utilizando Linux, el archivo de host está en `/etc/hosts`.

````bash
# Agregado por Martin, para que Keycloak funcione en nuestro entorno local
127.0.0.1 Keycloak
````

**¿Por qué necesitamos esa entrada?**

- Los contenedores pueden comunicarse entre sí utilizando alias de red o direcciones MAC, pero nuestro Postman necesita
  usar `localhost` para invocar los servicios.
- Necesitamos acceder a los servicios desde fuera de los contenedores (por ejemplo, usando Postman desde tu máquina
  local). Para esto, el host local (localhost) debe resolver el nombre `Keycloak` a la dirección IP `127.0.0.1`.
- Cuando usas Postman para hacer solicitudes a tus servicios protegidos por `Keycloak`, `Postman` debe saber cómo
  resolver el nombre `Keycloak`. Al agregar la entrada `127.0.0.1 Keycloak` en el archivo hosts, estás diciendo a tu
  máquina que el nombre `Keycloak` debe ser resuelto a `127.0.0.1 (localhost)`.
- Después de agregar esta entrada, cuando tu sistema intente acceder a `Keycloak` (por ejemplo, a través de Postman),
  resolverá el nombre `Keycloak` a la dirección IP `127.0.0.1`, permitiendo que las solicitudes lleguen al servicio
  Keycloak que está corriendo en tu máquina local.

## Configurando Keycloak

Ahora que tenemos `Keycloak` en `/docker/compose.yml`, ejecutemos el siguiente comando. Haremos esto en la carpeta raíz
de nuestro proyecto:

````bash
M:\PROGRAMACION\DESARROLLO_JAVA_SPRING\08.book_ms-in-action-2021\spring-microservices-in-action-2021 (main -> origin)
$ docker compose -f .\docker\compose.yml up -d
                                          
[+] Running 4/4                                                                          
 ✔ Network docker_default             Created                                        0.1s
 ✔ Volume "postgres_data"             Created                                        0.0s
 ✔ Container c-postgres-for-keycloak  Healthy                                       11.9s
 ✔ Container c-keycloak               Started                                       12.3s
````

**Nota**
> Normalmente, cuando ejecutamos el docker compose, lo haríamos así:
>
> `docker compose up -d`
>
> Pero eso lo hacemos siempre y cuando estemos ubicados en el mismo directorio que contiene el `compose.yml`, pero si
> estamos en otra ubicación, como en nuestro caso, tenemos que usar la bandera `-f` y agregar la ubicación del archivo.

Verificamos que nuestros contenedores se esté ejecutando:

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                              COMMAND                  CREATED         STATUS                   PORTS                              NAMES
6b42e797e151   quay.io/keycloak/keycloak:21.0.2   "/opt/keycloak/bin/k…"   2 minutes ago   Up 2 minutes             8443/tcp, 0.0.0.0:8181->8080/tcp   c-keycloak
1133d5314917   postgres:15.2-alpine               "docker-entrypoint.s…"   2 minutes ago   Up 2 minutes (healthy)   0.0.0.0:5435->5432/tcp             c-postgres-for-keycloak
````

Verificamos que las tablas de keycloak se hayan creado en nuestra base de datos:

````bash
$ docker container exec -it c-postgres-for-keycloak /bin/sh
/ # psql -U magadiflo -d db_keycloak
psql (15.2)
Type "help" for help.

db_keycloak=# \dt
                     List of relations
 Schema |             Name              | Type  |   Owner
--------+-------------------------------+-------+-----------
 ...
 public | client                        | table | magadiflo
 ...
 public | realm                         | table | magadiflo
 public | realm_attribute               | table | magadiflo
 public | realm_default_groups          | table | magadiflo
 public | realm_enabled_event_types     | table | magadiflo
 ...
 public | user_attribute                | table | magadiflo
 public | user_consent                  | table | magadiflo
 public | user_consent_client_scope     | table | magadiflo
 public | user_entity                   | table | magadiflo
 public | user_federation_config        | table | magadiflo
 public | user_federation_mapper        | table | magadiflo
 public | user_federation_mapper_config | table | magadiflo
 public | user_federation_provider      | table | magadiflo
 public | user_group_membership         | table | magadiflo
 public | user_required_action          | table | magadiflo
 public | user_role_mapping             | table | magadiflo
 public | user_session                  | table | magadiflo
 public | user_session_note             | table | magadiflo
 public | username_login_failure        | table | magadiflo
 public | web_origins                   | table | magadiflo
(92 rows)

db_keycloak=#
````

Ahora procedemos a ingresar al siguiente enlace `http://localhost:8181/`, buscamos el inicio de sesión en el apartado
de `Administration Console` e iniciamos sesión con el usuario y contraseña que definimos en el archivo `compose.yml`.

Para seguir configurando nuestros datos, creemos nuestro `realm`. Un `realm` es un concepto que utiliza `Keycloak` para
referirse a un objeto que administra un conjunto de `usuarios, credenciales, roles y grupos`. Para crear nuestro
`realm`, haga clic en la opción`Create Realm` que se muestra en el menú desplegable `Master` después de iniciar sesión
en `Keycloak`. Llamaremos a este `realm` `spmia-realm`.

![54.keycloak-spmia-realm.png](./assets/54.keycloak-spmia-realm.png)

## Registrando una aplicación cliente

El siguiente paso en nuestra configuración es crear un cliente. Los clientes en `Keycloak` son entidades que pueden
solicitar autenticación de usuario. Los clientes suelen ser las aplicaciones o servicios que queremos proteger
proporcionando una solución de `inicio de sesión único (SSO)`. Para crear un cliente, hagamos clic en la opción
Clientes en el menú de la izquierda.

Una vez que se muestra la lista de Clientes, haga clic en el botón `Create client` (que se muestra en la esquina
superior derecha de la tabla). Una vez que haga clic, verá un formulario donde agregaremos los siguientes datos:

![55.configuration-client.png](./assets/55.configuration-client.png)

En el cliente `ostock` que hemos creado, vamos al apartado de `Roles` y agregamos dos roles `ADMIN` y `USER`:

![56.roles-keycloak.png](./assets/56.roles-keycloak.png)

Ahora que hemos terminado la configuración básica de nuestro cliente, visitemos la página `Credentials`. La página
`Credentials` mostrará el secreto de cliente requerido para el proceso de autenticación. La siguiente imagen muestra
cómo se ve la página `Credentials`:

![57.credentials-ostock.png](./assets/57.credentials-ostock.png)

El siguiente paso en nuestra configuración es crear roles de `realm`. Los roles de `realm` nos permitirán tener un mejor
control de qué roles se establecen para cada usuario. Este es un paso opcional. Si no desea crear estos roles, puede
continuar y crear los usuarios directamente. Pero más adelante, podría resultar más difícil identificar y mantener los
roles de cada usuario.

Para crear los roles de `realm`, hagamos clic en la opción `Realm roles` que se muestra en el menú de la izquierda y
luego hagamos clic en el botón `Create role` en la parte superior derecha de la tabla. Al igual que con los roles de
cliente, crearemos dos tipos de realm roles: `ostock-user` y `ostock-admin`. La siguiente imagen muestra los dos roles
creados:

![58.realm-roles.png](./assets/58.realm-roles.png)

Ahora procedemos a configurar el real role `ostock-admin`, observemos que le estamos asociando el role `ADMIN`,
repitamos los mismos pasos para el role real `ostock-user`. Con respecto al `ostock-user` en la
pestaña `Associated roles` debemos asignarle el rol `USER`, para eso, al dar clic en el botón `Assign role` se nos
abrirá un modal, luego seleccionamos la opción `Filter by clients` y nos movemos entre la tabla hasta encontrar el
role `USER`.

![59.configuration-aditional.png](./assets/59.configuration-aditional.png)

Una vez que haya terminado, debería tener una lista similar a la que se muestra en la `figura 9.14`.

![60.composite-true.png](./assets/60.composite-true.png)

## Configurando usuarios de O-Stock

Ahora que hemos definido nombres, secretos a nivel de aplicación y de realm roles, estamos listos para configurar
las credenciales de usuario individuales y los roles para los usuarios. Para crear los usuarios, hagamos clic en la
opción `Users` que se muestra en el menú de la izquierda en la consola de administración de `Keycloak`.

Para los ejemplos de este capítulo, definiremos dos cuentas de usuario: `illary.huaylupo` y `john.carnell`. La cuenta
`john.carnell` tendrá el rol de `ostock-user` y la cuenta `illary.huaylupo` tendrá el rol de `ostock-user` y el de
`ostock-admin`. La Figura 9.15 muestra la página Agregar usuario.

A continuación se muestra la creación de los usuarios antes mencionados donde se les agregó a cada uno sus contraseñas
del `1 al 6`, además se les estableció un `Role mapping` según lo mencionado en el párrafo anterior. A continuación se
muestra cómo es que quedarían los dos usuarios creados:

![61.users.png](./assets/61.users.png)

## Autenticando a nuestros usuarios de O-Stock

En este punto, tenemos suficiente funcionalidad básica de nuestro servidor Keycloak para realizar la autenticación de
aplicaciones y usuarios para el flujo de concesión de contraseñas. Comencemos nuestro servicio de autenticación. Para
hacer esto, haga clic en la opción `Realm settings` en el menú de la izquierda y luego haga clic en el enlace
`OpenID Endpoint Configuration` para ver una lista de puntos finales disponibles para nuestro Realm. A continuación se
muestra parte del objeto json que nos retorna dicho enlace:

````bash
{
    "issuer": "http://localhost:8181/realms/spmia-realm",
    "authorization_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/auth",
    "token_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/token",
    "introspection_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/token/introspect",
    "userinfo_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/userinfo",
    "end_session_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/logout",
    "frontchannel_logout_session_supported": true,
    "frontchannel_logout_supported": true,
    "jwks_uri": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/certs",
    "check_session_iframe": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/login-status-iframe.html",
    "grant_types_supported": [
        "authorization_code",
        "implicit",
        "refresh_token",
        "password",
        "client_credentials",
        "urn:ietf:params:oauth:grant-type:device_code",
        "urn:openid:params:grant-type:ciba"
    ],
    ...
}
````

Ahora simularemos un usuario que quiere adquirir un `access token`. Haremos esto usando POSTMAN para realizar una
petición POST hacia el endpoint "
token_endpoint": `http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token` proporcionado en el resultado
anterior.

**NOTA**
> Recordemos que en apartados superiores configuramos el archivo `hosts` con `127.0.0.1 Keycloak`, precisamente eso nos
> da la posibilidad de en vez de usar localhost, usar `keycloack` en nuestra url.

Para simular que un usuario adquiere un token de autenticación, necesitamos configurar Postman con el nombre de la
aplicación y la clave secreta. Para ello, pasaremos estos elementos al punto final de nuestro servidor de autenticación
mediante autenticación básica. La Figura 9.20 muestra cómo está configurado Postman para ejecutar una llamada de
autenticación básica. Tenga en cuenta que usaremos el nombre de la aplicación que definimos previamente y la clave
secreta de la aplicación como contraseña:

![62.basic-authentication.png](./assets/62.basic-authentication.png)

Sin embargo, todavía no estamos listos para tomar la decisión de obtener el token. Una vez configurados el nombre de la
aplicación y la clave secreta, debemos pasar la siguiente información al servicio como parámetros del formulario HTTP:

- `grant_type`: el tipo de concesión que se ejecutará. En este ejemplo, usaremos una concesión de contraseña.
- `username`: nombre del usuario que inicia sesión.
- `password`: contraseña del usuario que inicia sesión.

La siguiente imagen muestra cómo se configuran estos parámetros del formulario HTTP para nuestra llamada de
autenticación. Además, a diferencia de otras llamadas REST de este libro, los parámetros de esta lista no se pasarán
como un cuerpo JSON. El estándar de autenticación espera que todos los parámetros pasados al endpoint de generación de
tokens sean parámetros de formulario HTTP. La siguiente imagen muestra la carga útil JSON devuelta por la llamada
`/openid-connect/token`.

![63.parameters-and-return-payload.png](./assets/63.parameters-and-return-payload.png)

En vez de usar POSTMAN, podemos hacer hacer la solicitud usando `curl`, de la siguiente manera:

````bash
$ curl -v -X POST -u ostock:gTcMs89AF64WlSQkSu22yTmm7se8cPt6 -d "grant_type=password&username=illary.huaylupo&password=123456" http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token | jq

* Connected to keycloak (127.0.0.1) port 8181
* Server auth using Basic with user 'ostock'
> POST /realms/spmia-realm/protocol/openid-connect/token HTTP/1.1
> Host: keycloak:8181
> Authorization: Basic b3N0b2NrOmdUY01zODlBRjY0V2xTUWtTdTIyeVRtbTdzZThjUHQ2
> User-Agent: curl/8.4.0
> Accept: */*
> Content-Length: 60
> Content-Type: application/x-www-form-urlencoded
>
} [60 bytes data]
< HTTP/1.1 200 OK
< Referrer-Policy: no-referrer
< X-Frame-Options: SAMEORIGIN
< Strict-Transport-Security: max-age=31536000; includeSubDomains
< Cache-Control: no-store
< X-Content-Type-Options: nosniff
< Set-Cookie: KEYCLOAK_LOCALE=; Version=1; Comment=Expiring cookie; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Max-Age=0; Path=/realms/spmia-realm/; HttpOnly
< Set-Cookie: KC_RESTART=; Version=1; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Max-Age=0; Path=/realms/spmia-realm/; HttpOnly
< Pragma: no-cache
< X-XSS-Protection: 1; mode=block
< Content-Type: application/json
< content-length: 2372
<
{ [2372 bytes data]
100  2432  100  2372  100    60  11187    282 --:--:-- --:--:-- --:--:-- 11692
* Connection #0 to host keycloak left intact
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzExMzcsImlhdCI6MTcxNjg3MDgzNywianRpIjoiNmZlY2U4N2QtOWE3OC00ZWU3LThiZTktOTcxNjQ0ZDVjY2QzIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjRhNjMzYjk3LWQ4ZTItNGY3NS1iNTkyLTBjZmNmZWU3ODViMiIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLWFkbWluIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiQURNSU4iLCJVU0VSIl19LCJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IklsYXJ5IEh1YXlsdXBvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaWxsYXJ5Lmh1YXlsdXBvIiwiZ2l2ZW5fbmFtZSI6IklsYXJ5IiwiZmFtaWx5X25hbWUiOiJIdWF5bHVwbyIsImVtYWlsIjoiaWxsYXJ5Lmh1YXlsdXBvQGdtYWlsLmNvbSJ9.S-E782qpgjYKsXR1lo_yhH_wWzH6MOLK2GRi0Zb3kxQqKuicWtzur3_NCIRN2QTyhWCsv-DBFS30y49OEiDLAMtXmSEOZcB3vL2vVD6r_ybm9evbvfIKZHZioAZr5_8k--6yZTp0JcuVKGKAqQmhqQx6EDJX-WCmc-WSEMn8D0nHef6b6vvwYQ3cNZoA4hyj62QjFyYVjkxBSaOISNzGtNeUF9ChfxpkTtpVumIhFdiUH2n5XzEmulGFTov5rq3q_2qW9ff8BQW4xuVGCBZDxlI4QnDllartJU07DGNsDLc2lJtiODLTlHJ0u-_A4cgR9S9Ky4V8a57c0OqMV1tWwA",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJiODc1NzEzMS02ZGQ3LTQyZWMtYWU0Mi0yMjNhZTIxYmY0MTMifQ.eyJleHAiOjE3MTY4NzI2MzcsImlhdCI6MTcxNjg3MDgzNywianRpIjoiNGI3ZjQzYmMtZmViOS00MGRlLWEzNGUtNzBlOWVlMDE2NWI2IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwic3ViIjoiNGE2MzNiOTctZDhlMi00Zjc1LWI1OTItMGNmY2ZlZTc4NWIyIiwidHlwIjoiUmVmcmVzaCIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMifQ.gcG_RwgGipqjlMe0jZCgyEqaFUJiWnd9p8ZCWeWpy7w",
  "token_type": "Bearer",
  "not-before-policy": 0,
  "session_state": "0831ef2a-6fb7-44a1-b1f1-7eda284a3163",
  "scope": "profile email"
}
````

El payload del JSON contiene cinco atributos:

- `access_token`: el token de acceso que se presentará con cada llamada de servicio que el usuario realiza a un recurso
  protegido.
- `token_type`: la especificación de autorización nos permite definir múltiples tipos de token. El tipo de token más
  común utilizado es el `Bearer token`. (No cubriremos ninguno de los otros tipos de tokens en este capítulo).
- `refresh_token`: el token de actualización se puede presentar nuevamente al servidor de autorización para volver a
  emitir un token después de que caduque.
- `expires_in`: este es el número de segundos antes de que caduque el token de acceso. El valor predeterminado para la
  caducidad del token de autorización en Spring es de 12 horas.
- `scope`: define el alcance para el cual este token de acceso es válido.

Ahora que hemos recuperado un token de acceso válido del servidor de autorización, podemos decodificar el JWT
con https://jwt.io para recuperar toda la información del token de acceso. La siguiente figura muestra los resultados
del JWT decodificado.

![64.jwt-decoded.png](./assets/64.jwt-decoded.png)

## Protegiendo el servicio de organización (servidor de recursos) usando Keycloak

Una vez que hayamos registrado un cliente en nuestro servidor `Keycloak` y hayamos configurado cuentas de usuario
individuales con roles, podemos comenzar a explorar cómo proteger un recurso usando `Spring Security` y `Keycloak`.
Si bien la creación y gestión de tokens de acceso es responsabilidad del servidor `Keycloak`, en Spring, la definición
de qué roles de usuario tienen permisos para realizar qué acciones ocurre en el nivel de servicio individual.

Comencemos con uno de los ejemplos más simples de configuración de un recurso protegido. Para eso, tomaremos nuestro
servicio de organización y nos aseguraremos de que solo un usuario autenticado pueda llamarlo.

## Agregando JARs al servicio de organización (servidor de recursos)

La mayor parte del soporte del servidor de recursos se recopila en `spring-security-oauth2-resource-server`. Sin
embargo, el soporte para decodificar y verificar `JWT` está en `spring-security-oauth2-jose`, lo que significa que ambos
son necesarios para tener un servidor de recursos en funcionamiento que admita `Bearer Tokens` codificados con `JWT`.
Spring Boot nos proporciona la siguiente dependencia que ya trae las dos dependencias anteriormente mencionadas. Esta
dependencia la agregaremos en el servicio `organization-service/pom.xml`:

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
````

## [Configurando el servicio de organización (servidor de recursos) para que apunte a nuestro servidor Keycloak](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html)

Cuando se utiliza `Spring Boot`, la configuración de una aplicación como `servidor de recursos` consta de dos pasos
básicos:

1. Primero, incluya las dependencias necesarias (ya la hicimos en el apartado anterior).
2. Segundo, indique la ubicación del servidor de autorización.

En una aplicación Spring Boot, para especificar qué servidor de autorización usar, simplemente definamos la siguiente
configuración. Esta configuración debemos agregarla al archivo de propiedades de la aplicación
del `organization-service` ubicado en el repositorio del `config server`:

````yml
# config-server/src/main/resources/config/organization-service.yml
spring:
  security:
  oauth2:
    resourceserver:
      jwt:
        issuer-uri: http://keycloak:8181/realms/spmia-realm
````

Donde `http://keycloak:8181/realms/spmia-realm` es el valor contenido en el claim `iss` para los tokens JWT que emitirá
el servidor de autorización. El `servidor de recursos` utilizará esta propiedad para una mayor autoconfiguración,
descubrir las claves públicas del servidor de autorización y, posteriormente, validar los JWT entrantes.

Para ver exactamente de dónde obtener el `issuer-uri`, podemos hacer dos cosas:

1. Acceder al endpoint `http://localhost:8181/realms/spmia-realm/.well-known/openid-configuration`. Si accedemos al
   endpoint anterior veremos que nos retorna un json con varios endpoints y configuraciones. Podemos acceder a
   ingresando a través del servidor de autorización de Keycloak y ubicar la opción `OpenID Endpoint Configuration`:

  ````bash
  {
    "issuer": "http://localhost:8181/realms/spmia-realm",
    "authorization_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/auth",
    "token_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/token",
    "introspection_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/token/introspect",
    "userinfo_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/userinfo",
    "end_session_endpoint": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/logout",
    "frontchannel_logout_session_supported": true,
    "frontchannel_logout_supported": true,
    "jwks_uri": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/certs",
    "check_session_iframe": "http://localhost:8181/realms/spmia-realm/protocol/openid-connect/login-status-iframe.html",
    "grant_types_supported": [
      "authorization_code"
    ],
    {...}
  }
  ````

Observemos que la propiedad `issuer` tiene el endpoint similar al que estamos usando.

2. Si solicitamos un access token al servidor de autorización de keycloak, lo podemos hacer así:

  ````bash
  $ curl -v -X POST -u ostock:gTcMs89AF64WlSQkSu22yTmm7se8cPt6 -d "grant_type=password&username=illary.huaylupo&password=123456" http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token | jq
  >
  < HTTP/1.1 200 OK
  <
  {
    "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzExMzcsImlhdCI6MTcxNjg3MDgzNywianRpIjoiNmZlY2U4N2QtOWE3OC00ZWU3LThiZTktOTcxNjQ0ZDVjY2QzIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjRhNjMzYjk3LWQ4ZTItNGY3NS1iNTkyLTBjZmNmZWU3ODViMiIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLWFkbWluIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiQURNSU4iLCJVU0VSIl19LCJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IklsYXJ5IEh1YXlsdXBvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaWxsYXJ5Lmh1YXlsdXBvIiwiZ2l2ZW5fbmFtZSI6IklsYXJ5IiwiZmFtaWx5X25hbWUiOiJIdWF5bHVwbyIsImVtYWlsIjoiaWxsYXJ5Lmh1YXlsdXBvQGdtYWlsLmNvbSJ9.S-E782qpgjYKsXR1lo_yhH_wWzH6MOLK2GRi0Zb3kxQqKuicWtzur3_NCIRN2QTyhWCsv-DBFS30y49OEiDLAMtXmSEOZcB3vL2vVD6r_ybm9evbvfIKZHZioAZr5_8k--6yZTp0JcuVKGKAqQmhqQx6EDJX-WCmc-WSEMn8D0nHef6b6vvwYQ3cNZoA4hyj62QjFyYVjkxBSaOISNzGtNeUF9ChfxpkTtpVumIhFdiUH2n5XzEmulGFTov5rq3q_2qW9ff8BQW4xuVGCBZDxlI4QnDllartJU07DGNsDLc2lJtiODLTlHJ0u-_A4cgR9S9Ky4V8a57c0OqMV1tWwA",
    "expires_in": 300,
    "refresh_expires_in": 1800,
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJiODc1NzEzMS02ZGQ3LTQyZWMtYWU0Mi0yMjNhZTIxYmY0MTMifQ.eyJleHAiOjE3MTY4NzI2MzcsImlhdCI6MTcxNjg3MDgzNywianRpIjoiNGI3ZjQzYmMtZmViOS00MGRlLWEzNGUtNzBlOWVlMDE2NWI2IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwic3ViIjoiNGE2MzNiOTctZDhlMi00Zjc1LWI1OTItMGNmY2ZlZTc4NWIyIiwidHlwIjoiUmVmcmVzaCIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMiLCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIwODMxZWYyYS02ZmI3LTQ0YTEtYjFmMS03ZWRhMjg0YTMxNjMifQ.gcG_RwgGipqjlMe0jZCgyEqaFUJiWnd9p8ZCWeWpy7w",
    "token_type": "Bearer",
    "not-before-policy": 0,
    "session_state": "0831ef2a-6fb7-44a1-b1f1-7eda284a3163",
    "scope": "profile email"
  }
  ````

Ahora, con el `access_token` podemos ir a la web `https://jwt.io/` para decodificarlo y observaremos su payload de la
siguiente manera:

  ````bash
  {
    "exp": 1716871137,
    "iat": 1716870837,
    "jti": "6fece87d-9a78-4ee7-8be9-971644d5ccd3",
    "iss": "http://keycloak:8181/realms/spmia-realm",
    "aud": "account",
    "sub": "4a633b97-d8e2-4f75-b592-0cfcfee785b2",
    "typ": "Bearer",
    "azp": "ostock",
    "session_state": "0831ef2a-6fb7-44a1-b1f1-7eda284a3163",
    ....
  }
  ````

Observemos que el claim `iss` tiene el valor que colocamos al `issuer-uri` del `organization-service.yml`. Notar que
aquí sí nos está diciendo `keycloak:8181...`, es decir, el dominio sí dice `keycloak` y no `localhost` como en el
primer caso. Esto es porque cuando hicimos la solicitud de obtener un `access_token` hicimos la petición al endpoint
`http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token` colocando `keycloak:8181` en vez de
`localhost:8181`. Si hubiéramos colocado el `localhost:8181` al endpoint para solicitar el access token, en el `iss`
del `jwt` nos habría venido como `localhost` y ya no como `keycloak`.

En resumen, el endpoint que colocamos en la siguiente configuración
`issuer-uri: http://keycloak:8181/realms/spmia-realm`, debe tener el dominio `keycloak` dado que el endpoint que usamos
para solicitar un `access_token` es un endpoint que utiliza como dominio el `keycloak`.

### Expectativas de inicio

Cuando esta propiedad (issuer-uri) y la dependencia (spring-boot-starter-oauth2-resource-server) son
usadas, `Resource Server` se configurará automáticamente para validar los `Brearer Tokens` codificados en `JWT`.

Lo logra a través de un proceso de inicio determinista:

1. Consultar el punto final de metadatos del servidor de autorización o configuración del proveedor para la propiedad
   `jwks_url`.
2. Consultar el punto final jwks_url para conocer los algoritmos admitidos
3. Configure la estrategia de validación para consultar jwks_url para obtener claves públicas válidas de los algoritmos
   encontrados.
4. Configure la estrategia de validación para validar cada claim iss de JWT contra http://keycloak:8181.

Una consecuencia de este proceso es que el servidor de autorización debe estar activo y recibiendo solicitudes para que
el servidor de recursos se inicie correctamente.

## [Sobreescribiendo o reemplazando la auto-configuración de arranque](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html#oauth2resourceserver-jwt-sansboot)

Spring Boot genera en nombre de `Resource Server` dos `@Beans`: `SecurityFilterChain` y el `JwtDecoder`.

En nuestro caso sobreescribiremos el `@Bean` `SecurityFilterChain` que **configura la aplicación como un servidor de
recursos**. Al incluir `spring-security-oauth2-jose`, este `SecurityFilterChain` se verá así:

````java
/**
 * The prePostEnabled property enables Spring Security pre/post annotations.
 * The securedEnabled property determines if the @Secured annotation should be enabled.
 * The jsr250Enabled property allows us to use the @RolesAllowed annotation.
 */
@EnableMethodSecurity(jsr250Enabled = true)
@EnableWebSecurity
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(authorize -> authorize.anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.jwtAuthenticationConverter(this.jwtAuthConverter())));
        return http.build();
    }

    // Convertir los roles de keycloak en una representación compatible con spring security
    private Converter<Jwt, ? extends AbstractAuthenticationToken> jwtAuthConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(new KeycloakRealmRoleConverter());
        return converter;
    }
}

@Slf4j
@SuppressWarnings("unchecked")
class KeycloakRealmRoleConverter implements Converter<Jwt, Collection<GrantedAuthority>> {

    @Override
    public Collection<GrantedAuthority> convert(Jwt source) {
        if (source.getClaims() == null) {
            return List.of();
        }
        final Map<String, Map<String, List<String>>> resourceAccess = (Map<String, Map<String, List<String>>>) source.getClaims().get("resource_access");
        final Map<String, List<String>> ostock = (Map<String, List<String>>) resourceAccess.get("ostock");
        return ostock.get("roles").stream()
                .map(roleName -> {
                    log.info("roleName: {}", roleName);
                    return "ROLE_" + roleName;
                })
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
````

## Protegiendo un servicio a través de un rol específico

En el siguiente ejemplo, bloquearemos la llamada `DELETE` en el servicio de nuestra organización y solo aquellos
usuarios que tienen el rol `ADMIN` podrán acceder. Como recordará de la sección 9.2.4, creamos dos cuentas de usuario
que pueden acceder a los servicios de O-stock: `illary.huaylupo` y `john.carnell`. La
cuenta `john.carnel tenía asignado el rol de USER`. La cuenta `illary.huaylupo tenía el rol USER y el rol ADMIN`.
Podemos permitir que roles específicos ejecuten algunos métodos usando la anotación `@RolesAllowed` o la anotación
`@PreAuthorize` en el controlador. También está la anotación `@Secured`, pero esta última anotación no la tenemos
habilitada. Recordar que para usar estas anotaciones tenemos que definir la anotación `@EnableMethodSecurity` en
la clase de configuración de spring security y habilitarlas manualmente con la excepción del `@PreAuthorize` que por
defecto ya viene habilitada, tal como se ve a continuación:

````java
/**
 * The prePostEnabled property enables Spring Security pre/post annotations (por defecto es true)
 * The securedEnabled property determines if the @Secured annotation should be enabled (por defecto false)
 * The jsr250Enabled property allows us to use the @RolesAllowed annotation (por defecto false)
 */

@EnableMethodSecurity(jsr250Enabled = true)
@EnableWebSecurity
@Configuration
public class SecurityConfig {

}
````

A continuación se muestra nuestro controlador del `organization-service` con los endpoints asegurados.
Recordar que estamos usando dos tipos de anotaciones `@PreAuthorize` y `@RolesAllowed` para asegurar los métodos.
Esto lo hago para ver las distintas anotaciones que tenemos para asegurar los endpoints.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/v1/organization")
public class OrganizationController {

    private final OrganizationService organizationService;

    @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    @GetMapping(path = "/{organizationId}")
    public ResponseEntity<Organization> getOrganization(@PathVariable String organizationId) {
        return ResponseEntity.ok(this.organizationService.findById(organizationId));
    }

    @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    @PostMapping
    public ResponseEntity<Organization> saveOrganization(@RequestBody Organization organization) {
        Organization organizationDB = this.organizationService.create(organization);
        URI location = URI.create("/v1/organization/" + organizationDB.getOrganizationId());
        return ResponseEntity.created(location).body(organizationDB);
    }

    @RolesAllowed({"ADMIN", "USER"})
    @PutMapping(path = "/{organizationId}")
    public ResponseEntity<Organization> updateOrganization(@PathVariable String organizationId, @RequestBody Organization organization) {
        return ResponseEntity.ok(this.organizationService.update(organization, organizationId));
    }

    @RolesAllowed("ADMIN")
    @DeleteMapping(path = "/{organizationId}")
    public ResponseEntity<Void> deleteOrganization(@PathVariable String organizationId) {
        this.organizationService.delete(organizationId);
        return ResponseEntity.noContent().build();
    }

}
````

Ahora, para obtener el token para `john.carnell` (contraseña: `123456`), necesitamos ejecutar la solicitud `POST`
`openid-connect/token` nuevamente.

````bash
$ curl -v -X POST -u ostock:gTcMs89AF64WlSQkSu22yTmm7se8cPt6 -d "grant_type=password&username=john.carnell&password=123456" http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token | jq
>
< HTTP/1.1 200 OK
<
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzM5MzEsImlhdCI6MTcxNjg3MzYzMSwianRpIjoiN2Y5MDc1NTQtYjAzNC00MDJkLThhMTgtMzc3MDJhM2M3ZjYzIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjYyNGY0MjE5LTE3YjgtNGNjYS1hNGE5LWNiZWRhY2M4ZmNjMCIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIyM2FmM2JiMC01MDg2LTQyYzctYjYwYi0yMTEwNDVjMGJkZjkiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiVVNFUiJdfSwiYWNjb3VudCI6eyJyb2xlcyI6WyJtYW5hZ2UtYWNjb3VudCIsIm1hbmFnZS1hY2NvdW50LWxpbmtzIiwidmlldy1wcm9maWxlIl19fSwic2NvcGUiOiJwcm9maWxlIGVtYWlsIiwic2lkIjoiMjNhZjNiYjAtNTA4Ni00MmM3LWI2MGItMjExMDQ1YzBiZGY5IiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm5hbWUiOiJKb2huIENhcm5lbGwiLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJqb2huLmNhcm5lbGwiLCJnaXZlbl9uYW1lIjoiSm9obiIsImZhbWlseV9uYW1lIjoiQ2FybmVsbCIsImVtYWlsIjoiam9obi5jYXJuZWxsQGdtYWlsLmNvbSJ9.GWJORnk80YSQnfULY7PgtFdXnSrv2OyGQh99HlFkpsBi1HHMHx9GcI5M7zX9xoZhduu-8NWaWm8ksMq5tvIKkAeK896FdQWjw9fzLiAyk5VX9mexImDuDXIMNVUMXYwr56vcFsx6TYyzKWIoHdiHGaiAX4h_VYWvIU-sLa7jyp6BYw01va-3H5wZQmkz58ruSLV9_Zvg3GJIQwJB43pQN0mgzMWccZt7hr2Af_HXUwpmkxmh5exqwNIl-j1Ln5V94YMuNS44Ou9ou11tFgpvwWK-20OCYVI85r0jppLcmkP5ao_ssVkJyzUnlrQqrc30FNXm0PNFLv9cj3mjdj62rA",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJiODc1NzEzMS02ZGQ3LTQyZWMtYWU0Mi0yMjNhZTIxYmY0MTMifQ.eyJleHAiOjE3MTY4NzU0MzEsImlhdCI6MTcxNjg3MzYzMSwianRpIjoiNTdhYjY4ODgtMzM5Mi00ZjA1LWFkNmYtYjNiMjhlNTFkMDdmIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwic3ViIjoiNjI0ZjQyMTktMTdiOC00Y2NhLWE0YTktY2JlZGFjYzhmY2MwIiwidHlwIjoiUmVmcmVzaCIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIyM2FmM2JiMC01MDg2LTQyYzctYjYwYi0yMTEwNDVjMGJkZjkiLCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIyM2FmM2JiMC01MDg2LTQyYzctYjYwYi0yMTEwNDVjMGJkZjkifQ.n_dLI79oVffZWIO7lBDYyGsWT8MVp-d0kittzd7hWHQ",
  "token_type": "Bearer",
  "not-before-policy": 0,
  "session_state": "23af3bb0-5086-42c7-b60b-211045c0bdf9",
  "scope": "profile email"
}
````

Una vez que tengamos el nuevo `access_token`, debemos llamar al endpoint `DELETE` para el servicio de la organización.
La llamada lo haremos apuntando al `gateway service`
`http://localhost:8072/organization/v1/organization/57862493-e212-4aa4-90d2-415ae258e625` y será este servidor que
redireccionará al servicio de la organización pasándole todos los datos que le estemos enviando.

Como observamos, estamos recibiendo un código de estado `HTTP 403 Prohibido` en la llamada y un mensaje de error que
indica que se denegó el acceso a este servicio y que la
`la solicitud requiere privilegios más altos que los proporcionados por el token de acceso`:

````bash
$ curl -v -X DELETE -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzM5MzEsImlhdCI6MTcxNjg3MzYzMSwianRpIjoiN2Y5MDc1NTQtYjAzNC00MDJkLThhMTgtMzc3MDJhM2M3ZjYzIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjYyNGY0MjE5LTE3YjgtNGNjYS1hNGE5LWNiZWRhY2M4ZmNjMCIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIyM2FmM2JiMC01MDg2LTQyYzctYjYwYi0yMTEwNDVjMGJkZjkiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiVVNFUiJdfSwiYWNjb3VudCI6eyJyb2xlcyI6WyJtYW5hZ2UtYWNjb3VudCIsIm1hbmFnZS1hY2NvdW50LWxpbmtzIiwidmlldy1wcm9maWxlIl19fSwic2NvcGUiOiJwcm9maWxlIGVtYWlsIiwic2lkIjoiMjNhZjNiYjAtNTA4Ni00MmM3LWI2MGItMjExMDQ1YzBiZGY5IiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm5hbWUiOiJKb2huIENhcm5lbGwiLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJqb2huLmNhcm5lbGwiLCJnaXZlbl9uYW1lIjoiSm9obiIsImZhbWlseV9uYW1lIjoiQ2FybmVsbCIsImVtYWlsIjoiam9obi5jYXJuZWxsQGdtYWlsLmNvbSJ9.GWJORnk80YSQnfULY7PgtFdXnSrv2OyGQh99HlFkpsBi1HHMHx9GcI5M7zX9xoZhduu-8NWaWm8ksMq5tvIKkAeK896FdQWjw9fzLiAyk5VX9mexImDuDXIMNVUMXYwr56vcFsx6TYyzKWIoHdiHGaiAX4h_VYWvIU-sLa7jyp6BYw01va-3H5wZQmkz58ruSLV9_Zvg3GJIQwJB43pQN0mgzMWccZt7hr2Af_HXUwpmkxmh5exqwNIl-j1Ln5V94YMuNS44Ou9ou11tFgpvwWK-20OCYVI85r0jppLcmkP5ao_ssVkJyzUnlrQqrc30FNXm0PNFLv9cj3mjdj62rA" http://localhost:8072/organization/v1/organization/57862493-e212-4aa4-90d2-415ae258e625 | jq
>
< HTTP/1.1 403 Forbidden
< Vary: Origin
< Vary: Access-Control-Request-Method
< Vary: Access-Control-Request-Headers
< WWW-Authenticate: Bearer error="insufficient_scope", error_description="The request requires higher privileges than provided by the access token.", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Length: 0
< Date: Tue, 28 May 2024 05:22:20 GMT
< tmx-correlation-id: 23352f20-7bb7-4f49-9984-dc16449e14f9
<
````

**NOTA**
> Usamos el puerto `8072` porque es el puerto que definimos para `Spring Cloud Gateway` en el capítulo anterior
> (específicamente en el archivo de configuración `gateway-server.yml` ubicado en el repositorio del servicio
> `Spring Cloud Configuration`)

Si intentáramos la misma llamada usando la cuenta de usuario `illary.huaylupo` (contraseña: `123456`) y su
token de acceso, veríamos una llamada exitosa que no devuelve ningún contenido y el código de estado `HTTP 204`,
Sin contenido.

````bash
$ curl -v -X POST -u ostock:gTcMs89AF64WlSQkSu22yTmm7se8cPt6 -d "grant_type=password&username=illary.huaylupo&password=123456" http://keycloak:8181/realms/spmia-realm/protocol/openid-connect/token | jq
>
< HTTP/1.1 200 OK
<
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzQ2ODgsImlhdCI6MTcxNjg3NDM4OCwianRpIjoiOTE4MWU5ZDQtYmRiNy00NzI0LWE1N2EtZTFhYzhhZjVlMmI2IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjRhNjMzYjk3LWQ4ZTItNGY3NS1iNTkyLTBjZmNmZWU3ODViMiIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjciLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLWFkbWluIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiQURNSU4iLCJVU0VSIl19LCJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IklsYXJ5IEh1YXlsdXBvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaWxsYXJ5Lmh1YXlsdXBvIiwiZ2l2ZW5fbmFtZSI6IklsYXJ5IiwiZmFtaWx5X25hbWUiOiJIdWF5bHVwbyIsImVtYWlsIjoiaWxsYXJ5Lmh1YXlsdXBvQGdtYWlsLmNvbSJ9.B4CDJbleYOvdAkn4fwXcmbrFgitoAq2jLQ8MuAK8KoA3jiLdxFfFa3619yMWz7kxfQl89kp2kemlm-Sd4LyGDcusODzILNtGhR0hSICBWWaDVlGIJ4kfLNuoX2vNLbPq5icwRvrrQdTzTFoOzTZ1lAJ_BVuoyR-nOLD18P1LJJ5kXtTXmAZimFcuL8twXo8opHTtwk1ElHQCAOgIb4EToBaFyVcvKooGfrseQEa_Bit3h0poLiaF89Bs5K2uyouNrwlg0xgHUW2LUJQe3QwNU54j_hukcgzP-4pCSjREZktkkZE5M5a7IRwfNnf-u8XuPuGkgqnqsYHOSSY_E0aAYg",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJiODc1NzEzMS02ZGQ3LTQyZWMtYWU0Mi0yMjNhZTIxYmY0MTMifQ.eyJleHAiOjE3MTY4NzYxODgsImlhdCI6MTcxNjg3NDM4OCwianRpIjoiZTQyN2Y5OWUtMDc2NS00ZmE4LWI0OTMtYjg5OGRhZGYyMzg2IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwic3ViIjoiNGE2MzNiOTctZDhlMi00Zjc1LWI1OTItMGNmY2ZlZTc4NWIyIiwidHlwIjoiUmVmcmVzaCIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjciLCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjcifQ.MycglOanmC9wbYUU-4_6VGg4YXHOTb1Zz5gmpmijK3o",
  "token_type": "Bearer",
  "not-before-policy": 0,
  "session_state": "3ef872df-b9fc-43a7-a244-b761fd9343f7",
  "scope": "profile email"
}
````

Ahora, con el access token obtenido, realizamos la llamada al servicio de organización usando como punto de entrada
el endpoint del gateway server:

````bash
$ curl -v -X DELETE -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRb1RjV09yU3NNR3l3a2hwdW9YR1h3QjVaemUzZUt4SEdzUlVTazVub3NJIn0.eyJleHAiOjE3MTY4NzQ2ODgsImlhdCI6MTcxNjg3NDM4OCwianRpIjoiOTE4MWU5ZDQtYmRiNy00NzI0LWE1N2EtZTFhYzhhZjVlMmI2IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrOjgxODEvcmVhbG1zL3NwbWlhLXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6IjRhNjMzYjk3LWQ4ZTItNGY3NS1iNTkyLTBjZmNmZWU3ODViMiIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9zdG9jayIsInNlc3Npb25fc3RhdGUiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjciLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwiZGVmYXVsdC1yb2xlcy1zcG1pYS1yZWFsbSIsInVtYV9hdXRob3JpemF0aW9uIiwib3N0b2NrLWFkbWluIiwib3N0b2NrLXVzZXIiXX0sInJlc291cmNlX2FjY2VzcyI6eyJvc3RvY2siOnsicm9sZXMiOlsiQURNSU4iLCJVU0VSIl19LCJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJzaWQiOiIzZWY4NzJkZi1iOWZjLTQzYTctYTI0NC1iNzYxZmQ5MzQzZjciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IklsYXJ5IEh1YXlsdXBvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaWxsYXJ5Lmh1YXlsdXBvIiwiZ2l2ZW5fbmFtZSI6IklsYXJ5IiwiZmFtaWx5X25hbWUiOiJIdWF5bHVwbyIsImVtYWlsIjoiaWxsYXJ5Lmh1YXlsdXBvQGdtYWlsLmNvbSJ9.B4CDJbleYOvdAkn4fwXcmbrFgitoAq2jLQ8MuAK8KoA3jiLdxFfFa3619yMWz7kxfQl89kp2kemlm-Sd4LyGDcusODzILNtGhR0hSICBWWaDVlGIJ4kfLNuoX2vNLbPq5icwRvrrQdTzTFoOzTZ1lAJ_BVuoyR-nOLD18P1LJJ5kXtTXmAZimFcuL8twXo8opHTtwk1ElHQCAOgIb4EToBaFyVcvKooGfrseQEa_Bit3h0poLiaF89Bs5K2uyouNrwlg0xgHUW2LUJQe3QwNU54j_hukcgzP-4pCSjREZktkkZE5M5a7IRwfNnf-u8XuPuGkgqnqsYHOSSY_E0aAYg" http://localhost:8072/organization/v1/organization/57862493-e212-4aa4-90d2-415ae258e625 | jq
>
< HTTP/1.1 204 No Content
< Vary: Origin
< Vary: Access-Control-Request-Method
< Vary: Access-Control-Request-Headers
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Date: Tue, 28 May 2024 05:34:52 GMT
< tmx-correlation-id: 0cb4f72d-4155-4e86-acd5-0a7f244c95cb
<
````

En este punto, hemos visto cómo llamar y proteger un único servicio (el servicio de la organización) con `Keycloak`. Sin
embargo, a menudo en un entorno de microservicios tendremos varias llamadas de servicio para realizar una única
transacción. En este tipo de situaciones, debemos asegurarnos de que el **token de acceso se propague de una llamada de
servicio a otra.**

