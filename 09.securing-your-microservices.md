# Protegiendo tus microservicios

Pág. 240

---

Ahora que contamos con una arquitectura de microservicios robusta, la tarea de cubrir las vulnerabilidades de seguridad
se vuelve cada vez más esencial. En este capítulo, la seguridad y la vulnerabilidad van de la mano. **Definiremos
`vulnerabilidad` como una debilidad o falla presentada en una aplicación.** Por supuesto, todos los sistemas tienen
vulnerabilidades, pero la gran diferencia radica en si estas vulnerabilidades se explotan y causan daño.

Mencionar la seguridad a menudo provoca un gemido involuntario por parte de los desarrolladores. Entre los
desarrolladores escuchamos comentarios como: "Es obtuso, difícil de entender y aún más difícil de depurar". Sin embargo,
no encontraremos ningún desarrollador (excepto quizás un desarrollador sin experiencia) que diga que no se preocupa por
la seguridad. Proteger una arquitectura de microservicios es una tarea compleja y laboriosa que implica múltiples capas
de protección, incluidas las siguientes:

- `La capa de aplicación`: garantiza que existan los controles de usuario adecuados para que podamos validar que un
  usuario es quien dice ser y que tiene permiso para hacer lo que está intentando hacer.
- `Infraestructura`: mantiene el servicio en funcionamiento, parcheado y actualizado para minimizar el riesgo de
  vulnerabilidades.
- `Una capa de red`: implementa controles de acceso a la red para que solo se pueda acceder a un servicio a través de
  puertos bien definidos y solo para una pequeña cantidad de servidores autorizados.

Este capítulo solo cubre cómo autenticar y autorizar usuarios en nuestra `capa de aplicación` (el primer punto de la
lista). Los otros dos elementos son temas de seguridad extremadamente amplios que están fuera del alcance de este libro.
Además, existen otras herramientas, como el Proyecto OWASP Dependency-Check, que pueden ayudar a identificar
vulnerabilidades.

Para implementar controles de autorización y autenticación, usaremos el módulo `Spring Cloud Security` y `Keycloak` para
proteger nuestros servicios basados en Spring. `Keycloak` es un software de gestión de acceso e identidad de código
abierto para aplicaciones y servicios modernos. Este software de código abierto está escrito en Java y admite protocolos
de identidad federados SAML (Security Assertion Markup Language) v2 y OpenID Connect (OIDC)/OAuth2.

## 9.1 ¿Qué es OAuth2?

`OAuth2` es un marco de seguridad basado en tokens que describe patrones para otorgar autorización pero no define cómo
realizar realmente la autenticación. En cambio, permite a los usuarios autenticarse con un servicio de autenticación de
terceros, llamado `proveedor de identidad (IdP)`. Si el usuario se autentica correctamente, se le presenta un token que
debe enviarse con cada solicitud. Luego, el token se puede volver a validar en el servicio de autenticación.

El objetivo principal detrás de `OAuth2` es que cuando se llaman varios servicios para cumplir con la solicitud de un
usuario, cada servicio puede autenticar al usuario sin tener que presentar sus credenciales a cada servicio que procese
su solicitud. `OAuth2` nos permite proteger nuestros servicios basados en REST en diferentes escenarios mediante
esquemas de autenticación llamados concesiones `(grants)`. La especificación `OAuth2` tiene cuatro tipos de concesiones:

- Password
- Client credentials
- Authorization code
- Implicit

**NOTA**
> Actualmente `Implicit` y el `Password` son concesiones legacy, mientras que hay otras que han surgido como el
> `PKCE` que es similar al `Authorization Code`. Para más información visitar mi repositorio de
> [spring-security-in-action-2020](https://github.com/magadiflo/spring-security-in-action-2020/blob/main/12.1.oauth2_y_open-id-connect.md)

No vamos a analizar cada uno de estos tipos de subvenciones ni a proporcionar ejemplos de código para cada uno. Es
demasiado material para cubrirlo en un solo capítulo. En su lugar, haremos lo siguiente:

- Analice cómo nuestros microservicios pueden usar OAuth2 a través de uno de los tipos de concesión de OAuth2 más
  simples, el tipo de concesión de password.
- Utilice tokens web JSON (JWT) para proporcionar una solución OAuth2 más sólida y establecer un estándar para codificar
  información en un token OAuth2.
- Analice otras consideraciones de seguridad que deben tenerse en cuenta al crear microservicios.

**NOTA**
> Proporcionamos una descripción general de los otros tipos de concesiones de OAuth2 en el apéndice B. Si está
> interesado en profundizar en más detalles sobre la especificación de OAuth2 y cómo implementar todos los tipos de
> concesiones, le recomendamos encarecidamente el libro de Justin Richer y Antonio Sanso, OAuth2 en Action (Manning,
> 2017), que es una explicación completa de OAuth2.

El verdadero poder detrás de `OAuth2` es que permite a los desarrolladores de aplicaciones integrarse fácilmente con
proveedores de nube externos y autenticar y autorizar a los usuarios con esos servicios sin tener que pasar las
credenciales del usuario continuamente al servicio de terceros.

`OpenID Connect (OIDC)` es una capa encima del marco OAuth2 que proporciona autenticación e información de perfil sobre
quién ha iniciado sesión en la aplicación (la identidad). Cuando un servidor de autorización admite OIDC, a veces se le
denomina proveedor de identidad. Antes de entrar en los detalles técnicos de la protección de nuestros servicios,
repasemos la arquitectura de `Keycloak`.

## 9.2 Introducción a Keycloak

`Keycloak` es una solución de gestión de acceso e identidad de código abierto para nuestros servicios y aplicaciones. El
principal objetivo de Keycloak es facilitar la protección de los servicios y aplicaciones con poco o ningún código.
Algunas características de Keycloak incluyen las siguientes:

- Centraliza la autenticación y permite la autenticación de inicio de sesión único (SSO).
- Permite a los desarrolladores centrarse en la funcionalidad empresarial en lugar de preocuparse por aspectos de
  seguridad como la autorización y la autenticación.
- Permite la autenticación de dos factores.
- Es compatible con LDAP.
- Ofrece varios adaptadores para proteger aplicaciones y servidores fácilmente.
- Le permite personalizar las políticas de contraseñas.

![53.flow-keycloak.png](./assets/53.flow-keycloak.png)

La seguridad de `Keycloak` se puede dividir en estos cuatro componentes: recurso protegido, propietario del recurso,
aplicación y servidor de autenticación/autorización. La `figura 9.1` muestra cómo interactúan los cuatro componentes.

- `Un recurso protegido`: el recurso (en nuestro caso, un microservicio) que desea proteger, garantizando que solo los
  usuarios autenticados que tengan la autorización adecuada puedan acceder a él.


- `Un propietario de recurso`: este propietario define qué aplicaciones pueden llamar al servicio, qué usuarios tienen
  acceso al servicio y qué pueden hacer los usuarios con el servicio. Cada aplicación registrada por el propietario del
  recurso recibe un nombre de aplicación que la identifica, junto con una clave secreta. La combinación del nombre de la
  aplicación y la clave secreta son parte de las credenciales que se pasan al autenticar un token de acceso.


- `Una aplicación`: esta es la aplicación que llamará al servicio en nombre de un usuario. Después de todo, los usuarios
  rara vez invocan un servicio directamente. En cambio, dependen de una aplicación para que haga el trabajo por ellos.


- `Servidor de autenticación/autorización`: el servidor de autenticación es el intermediario entre la aplicación y los
  servicios que se consumen. El servidor de autenticación permite al usuario autenticarse sin tener que pasar sus
  credenciales de usuario a cada servicio que la aplicación llamará en su nombre.

Como se mencionó anteriormente, los componentes de seguridad de `Keycloak` interactúan entre sí para autenticar a los
usuarios del servicio. Los usuarios se autentican en el servidor Keycloak proporcionando sus credenciales y la
aplicación/dispositivo que están utilizando para acceder a un recurso protegido (el microservicio). Si las credenciales
de los usuarios son válidas, el servidor Keycloak proporciona un token de autenticación que se puede pasar de un
servicio a otro cada vez que los usuarios utilizan un servicio.

Luego, el recurso protegido puede comunicarse con el servidor Keycloak para determinar la validez del token y recuperar
los roles asignados para un usuario. Los roles se utilizan para agrupar usuarios relacionados y definir a qué recursos
pueden acceder. En este capítulo, usaremos roles de Keycloak para determinar qué verbos HTTP puede usar un usuario para
llamar a qué puntos finales de servicio autorizados.

La seguridad de los servicios web es un tema extremadamente complicado. Necesitamos comprender quién llamará a nuestros
servicios (usuarios internos o usuarios externos), cómo llamarán a nuestro servicio (cliente web interno, dispositivo
móvil o aplicación web) y qué acciones realizarán con nuestro código.

**Sobre autenticación vs autorización**

> A menudo hemos descubierto que los desarrolladores "mezclan y combinan" el significado de los términos `autenticación`
> y `autorización`. La `autenticación` es el acto de un usuario que demuestra quién es proporcionando credenciales.
> La `autorización` determina si un usuario puede hacer lo que quiere hacer. Por ejemplo, la usuaria Illary podría
> demostrar su identidad proporcionando un ID de usuario y una contraseña, pero es posible que no esté autorizada a
> consultar datos confidenciales (datos de nómina, por ejemplo). Para nuestra discusión, un usuario debe autenticarse
> antes de que se realice la autorización.

## 9.3 Empezando poco a poco: usando Spring y Keycloak para proteger un único endpoint

Para comprender cómo configurar las piezas de autenticación y autorización, haremos lo siguiente:

- Agregue un servicio Keycloak a Docker.
- Configure un servicio Keycloak y registre la aplicación O-stock como una aplicación autorizada que puede autenticar y
  autorizar identidades de usuarios.
- Utilice Spring Security para proteger nuestros servicios O-stock. No vamos a crear una interfaz de usuario para
  O-stock; en su lugar, simularemos un usuario que inicia sesión en Postman para proporcionar autenticación para nuestro
  servicio Keycloak.
- Proteger los servicios de organización y licencias para que solo puedan ser llamados por un usuario autenticado.

## [Agregando Keycloak a Docker](https://www.keycloak.org/getting-started/getting-started-docker)

Esta sección explica cómo agregar el servicio `Keycloak` a nuestro entorno `Docker`. Para lograr esto, trabajaremos
con docker compose, por lo tanto, crearemos el directorio `/docker` y dentro de él el archivo `compose.yml`,
ahora, agregaremos las siguientes configuraciones en nuestro archivo `/docker/compose.yml`:

````yml
services:
  keycloak:
    image: quay.io/keycloak/keycloak:21.0.2
    container_name: c-keycloak
    restart: unless-stopped
    command:
      - 'start-dev'
    ports:
      - 8181:8080
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
````

**NOTA**
> Puede utilizar Keycloak con varias bases de datos como H2, PostgreSQL, MySQL, Microsoft SQL Server, Oracle y MariaDB.
> Para los ejemplos de este capítulo, usaremos la base de datos H2 incorporada predeterminada. Recomendamos
> encarecidamente visitar el siguiente enlace si desea utilizar otra base de datos: https://www.keycloak.org/server/db

Para que `Keycloak` funcione en nuestro entorno local, necesitamos agregar la entrada de host `127.0.0.1 Keycloak` a
nuestro archivo de `hosts`. Si está utilizando Windows, debe agregar la entrada de host en
`C:\Windows\System32\drivers\etc\hosts`, y si está utilizando Linux, el archivo de host está en `/etc/hosts`.

````bash
# Agregado por Martin, para que Keycloak funcione en nuestro entorno local
127.0.0.1 Keycloak
````

**¿Por qué necesitamos esa entrada?**

- Los contenedores pueden comunicarse entre sí utilizando alias de red o direcciones MAC, pero nuestro Postman necesita
  usar `localhost` para invocar los servicios.
- Necesitamos acceder a los servicios desde fuera de los contenedores (por ejemplo, usando Postman desde tu máquina
  local). Para esto, el host local (localhost) debe resolver el nombre `Keycloak` a la dirección IP `127.0.0.1`.
- Cuando usas Postman para hacer solicitudes a tus servicios protegidos por `Keycloak`, `Postman` debe saber cómo
  resolver el nombre `Keycloak`. Al agregar la entrada `127.0.0.1 Keycloak` en el archivo hosts, estás diciendo a tu
  máquina que el nombre `Keycloak` debe ser resuelto a `127.0.0.1 (localhost)`.
- Después de agregar esta entrada, cuando tu sistema intente acceder a `Keycloak` (por ejemplo, a través de Postman),
  resolverá el nombre `Keycloak` a la dirección IP `127.0.0.1`, permitiendo que las solicitudes lleguen al servicio
  Keycloak que está corriendo en tu máquina local.

## Configurando Keycloak

Ahora que tenemos `Keycloak` en `/docker/compose.yml`, ejecutemos el siguiente comando. Haremos esto en la carpeta raíz
de nuestro proyecto:

````bash
M:\PROGRAMACION\DESARROLLO_JAVA_SPRING\08.book_ms-in-action-2021\spring-microservices-in-action-2021 (main -> origin)
$ docker compose -f .\docker\compose.yml up -d

[+] Running 2/2
 ✔ Network docker_default  Created        0.1s
 ✔ Container c-keycloak    Started        0.1
````

**Nota**
> Normalmente, cuando ejecutamos el docker compose, lo haríamos así:
>
> `docker compose up -d`
>
> Pero eso lo hacemos siempre y cuando estemos ubicados en el mismo directorio que contiene el `compose.yml`, pero si
> estamos en otra ubicación, como en nuestro caso, tenemos que usar la bandera `-f` y agregar la ubicación del archivo.

Verificamos que nuestro contenedor se esté ejecutando:

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                              COMMAND                  CREATED         STATUS         PORTS                              NAMES
37158e305c98   quay.io/keycloak/keycloak:21.0.2   "/opt/keycloak/bin/k…"   9 minutes ago   Up 9 minutes   8443/tcp, 0.0.0.0:8181->8080/tcp   c-keycloak
````

Ahora procedemos a ingresar al siguiente enlace `http://localhost:8181/`, buscamos el inicio de sesión en el apartado
de `Administration Console` e iniciamos sesión con el usuario y contraseña que definimos en el archivo `compose.yml`.

Para seguir configurando nuestros datos, creemos nuestro `realm`. Un `realm` es un concepto que utiliza `Keycloak` para
referirse a un objeto que administra un conjunto de `usuarios, credenciales, roles y grupos`. Para crear nuestro
`realm`, haga clic en la opción`Create Realm` que se muestra en el menú desplegable `Master` después de iniciar sesión
en `Keycloak`. Llamaremos a este `realm` `spmia-realm`.

![54.keycloak-spmia-realm.png](./assets/54.keycloak-spmia-realm.png)

## Registrando una aplicación cliente

El siguiente paso en nuestra configuración es crear un cliente. Los clientes en `Keycloak` son entidades que pueden
solicitar autenticación de usuario. Los clientes suelen ser las aplicaciones o servicios que queremos proteger
proporcionando una solución de `inicio de sesión único (SSO)`. Para crear un cliente, hagamos clic en la opción
Clientes en el menú de la izquierda.

Una vez que se muestra la lista de Clientes, haga clic en el botón `Create client` (que se muestra en la esquina
superior derecha de la tabla). Una vez que haga clic, verá un formulario donde agregaremos los siguientes datos:

![55.configuration-client.png](./assets/55.configuration-client.png)

En el cliente `ostock` que hemos creado, vamos al apartado de `Roles` y agregamos dos roles `ADMIN` y `USER`:

![56.roles-keycloak.png](./assets/56.roles-keycloak.png)

Ahora que hemos terminado la configuración básica de nuestro cliente, visitemos la página `Credentials`. La página
`Credentials` mostrará el secreto de cliente requerido para el proceso de autenticación. La siguiente imagen muestra
cómo se ve la página `Credentials`:

![57.credentials-ostock.png](./assets/57.credentials-ostock.png)

El siguiente paso en nuestra configuración es crear roles de `realm`. Los roles de `realm` nos permitirán tener un mejor
control de qué roles se establecen para cada usuario. Este es un paso opcional. Si no desea crear estos roles, puede
continuar y crear los usuarios directamente. Pero más adelante, podría resultar más difícil identificar y mantener los
roles de cada usuario.

Para crear los roles de `realm`, hagamos clic en la opción `Realm roles` que se muestra en el menú de la izquierda y
luego hagamos clic en el botón `Create role` en la parte superior derecha de la tabla. Al igual que con los roles de
cliente, crearemos dos tipos de realm roles: `ostock-user` y `ostock-admin`. La siguiente imagen muestra los dos roles
creados:

![58.realm-roles.png](./assets/58.realm-roles.png)

Ahora procedemos a configurar el real role `ostock-admin`, repitamos los mismos pasos para el role real `ostock-user`.

![59.configuration-aditional.png](./assets/59.configuration-aditional.png)

Una vez que haya terminado, debería tener una lista similar a la que se muestra en la `figura 9.14`.

![60.composite-true.png](./assets/60.composite-true.png)

