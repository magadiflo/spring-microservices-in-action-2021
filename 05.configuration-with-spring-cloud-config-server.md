# Controlando su configuración con Spring Cloud Config Server

[Pág. 110] Capítulo 5

---

Muchos desarrolladores recurren a archivos de propiedades (YAML, JSON o XML) para almacenar su información de
configuración. Configurar su aplicación en estos archivos se convierte en una tarea simple, tan fácil que la mayoría de
los desarrolladores nunca hacen más que colocar su archivo de configuración bajo control de código fuente (si es así) e
implementar el archivo como parte de su aplicación. Este enfoque puede funcionar con una pequeña cantidad de
aplicaciones, pero rápidamente se desmorona cuando se trata de aplicaciones basadas en la nube que pueden contener
cientos de microservicios, donde cada microservicio, a su vez, puede tener múltiples instancias de servicio en
ejecución.

Por ejemplo, imaginemos que tenemos cientos de microservicios y cada microservicio contiene diferentes configuraciones
para tres entornos. Si no gestionamos esos archivos fuera de la aplicación, cada vez que haya un cambio deberemos buscar
el archivo en el repositorio de códigos, seguir el proceso de integración (si lo hay) y reiniciar la aplicación. Para
evitar este escenario catastrófico, como mejor práctica para el desarrollo de microservicios basados en la nube,
debemos considerar lo siguiente:

- Separe completamente la configuración de una aplicación del código real que se está implementando.


- Cree imágenes de aplicaciones inmutables que nunca cambien a medida que se promocionan en sus entornos.


- Inyecte cualquier información de configuración de la aplicación al inicio del servidor a través de variables de
  entorno o un repositorio centralizado que los microservicios leen al inicio.

## Sobre la gestión de la configuración (y la complejidad)

Comencemos nuestra discusión sobre la gestión de la configuración de aplicaciones estableciendo cuatro principios que
queremos seguir:

- `Segregar`: necesitamos separar completamente la información de configuración del servicio de la implementación física
  real de un servicio. De hecho, la configuración de la aplicación no debería implementarse con la instancia de
  servicio. En su lugar, la información de configuración debe pasarse como variables de entorno al iniciar el servicio o
  leerse desde un repositorio centralizado cuando se inicia el servicio.


- `Abstraer`: también necesitamos abstraer el acceso a los datos de configuración detrás de una interfaz de servicio.
  En lugar de escribir código que lea directamente el repositorio de servicios, ya sea basado en archivos o en una base
  de datos JDBC, deberíamos utilizar un servicio JSON basado en REST para recuperar los datos de configuración de la
  aplicación.


- `Centralizar`: debido a que una aplicación basada en la nube puede tener literalmente cientos de servicios, es
  fundamental minimizar la cantidad de repositorios diferentes utilizados para almacenar datos de configuración.
  Centralice la configuración de su aplicación en la menor cantidad de repositorios posible.


- `Reforzar`: debido a que la información de configuración de su aplicación estará completamente segregada de su
  servicio implementado y centralizada, es fundamental que la solución que utilice e implemente tenga alta
  disponibilidad y sea redundante.

Una de las cosas clave que debe recordar es que cuando separa su información de configuración fuera de su código real,
está creando una dependencia externa que deberá administrarse y controlarse. No podemos enfatizar lo suficiente que es
necesario rastrear los datos de configuración de la aplicación y controlar la versión porque la configuración de la
aplicación mal administrada es un caldo de cultivo para errores difíciles de detectar e interrupciones no planificadas.

## Su arquitectura de Gestión de la Configuración

Como recordará de los capítulos anteriores, la carga de la gestión de configuración de un microservicio se produce
durante la fase de arranque del microservicio. Como recordatorio, la figura 5.1 muestra el ciclo de vida del
microservicio.

![18.lifecycle-microservices.png](./assets/18.lifecycle-microservices.png)

Tomemos los cuatro principios que presentamos en la sección 5.1 (`segregar`, `abstraer`, `centralizar` y `reforzar`) y
veamos cómo se aplican cuando se inicia el servicio. La Figura 5.2 presenta el proceso de arranque con más detalle y
muestra cómo un servicio de configuración juega un papel crítico en este paso.

![19.configuration-management-architecture.png](./assets/19.configuration-management-architecture.png)

En la figura 5.2, se están llevando a cabo varias actividades. Aquí hay un resumen de cada paso en la figura:

1. Cuando aparece una instancia de microservicio, llama a un punto final de servicio para leer su información de
   configuración, que es específica del entorno en el que opera. La información de conexión para la administración de la
   configuración (credenciales de conexión, punto final de servicio, etc.) luego pasa a el microservicio cuando se
   inicia.


2. La configuración real reside en un repositorio. Según la implementación de su repositorio de configuración, puede
   elegir diferentes formas de conservar sus datos de configuración. Esto puede incluir archivos bajo control de fuente,
   bases de datos relacionales o almacenes de datos de valores-clave.


3. La gestión real de los datos de configuración de la aplicación se produce independientemente de cómo se implemente la
   aplicación. Los cambios en la gestión de la configuración generalmente se manejan a través del proceso de compilación
   e implementación, donde las modificaciones se pueden etiquetar con información de versión e implementar en los
   diferentes entornos (desarrollo, preparación, producción, etc.).


4. Cuando cambie la gestión de la configuración, los servicios que utilizan los datos de configuración de esa aplicación
   deben ser notificados de la alteración y actualizar su copia de los datos de la aplicación.

En este punto, hemos trabajado en la arquitectura conceptual que ilustra las diferentes piezas de un patrón de gestión
de configuración y cómo estas piezas encajan entre sí. Ahora veremos las diferentes soluciones para lograr la gestión de
la configuración y luego veremos un problema concreto.

## Opciones de implementación

Afortunadamente, puede elegir entre una gran cantidad de proyectos de código abierto probados en batalla para
implementar una solución de gestión de configuración. Veamos varias de las diferentes opciones disponibles y compárelas.
La tabla 5.1 presenta las opciones.

![20.open-source-projects.png](./assets/20.open-source-projects.png)

Todas las soluciones de la `tabla 5.1` se pueden utilizar fácilmente para crear una solución de gestión de
configuración. Para los ejemplos de este capítulo, y en el resto del libro,
usaremos` Spring Cloud Configuration Server` (a menudo llamado `Spring Cloud Config Server` o,
simplemente, `Config Server`), que se adapta perfectamente a nuestra arquitectura de microservicios Spring. Elegimos
esta solución porque:

- Spring Cloud Configuration Server es fácil de configurar y usar.

- Spring Cloud Config se integra estrechamente con Spring Boot. Literalmente puede leer todos los datos de configuración
  de su aplicación con algunas anotaciones fáciles de usar.

- Config Server ofrece múltiples backends para almacenar datos de configuración.

- De todas las soluciones en la tabla 5.1, Config Server puede integrarse directamente con la plataforma de control de
  fuente `Git` y con `HashiCorp Vault`. Explicaremos estos temas más adelante en este capítulo.

## Construyendo nuestro servidor de configuración Spring Cloud

`Spring Cloud Configuration Server` es una aplicación basada en REST que se basa en Spring Boot. El `Config Server` no
viene como un servidor independiente. En su lugar, puede optar por incrustarlo en una aplicación Spring Boot existente
o iniciar un nuevo proyecto Spring Boot con el servidor integrado. La mejor práctica es mantener las cosas separadas.

Lo primero que debemos hacer para construir nuestro servidor de configuración es crear un proyecto Spring Boot con
Spring Initializr (https://start.spring.io/).

Luego de crear el servicio `config-server`, el `pom.xml` ser verá de la siguiente manera:

````xml

<project>
    <!--Spring Boot 3.2.5-->
    <!--Java 21-->
    <!--spring-cloud.version 2023.0.1-->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
````

No analizaremos todo el archivo `pom` en detalle, pero para empezar tomaremos nota de algunas áreas clave. En el archivo
Maven anterior, podemos ver cuatro partes importantes. La primera es la `versión Spring Boot` y la siguiente es la
`versión Spring Cloud` que vamos a utilizar. En este ejemplo, utilizamos la versión `2023.0.1 de Spring Cloud`. El
tercer punto resaltado en la lista son las dependencias específicas que usaremos en el servicio, y el último punto es la
lista de materiales `(BOM)` principal de `Spring Cloud Config` que usaremos.

Esta lista de materiales principal contiene todas las bibliotecas y dependencias de terceros que se utilizan en el
proyecto de nube y los números de versión de los proyectos individuales que componen esa versión. En este ejemplo,
utilizamos la versión definida previamente en la sección `<properties>` del archivo `pom`. **Al utilizar una definición
de BOM, podemos garantizar que usaremos versiones compatibles de los subproyectos en Spring Cloud. También significa que
no tenemos que declarar números de versión para nuestras subdependencias.**

El siguiente paso en la creación de nuestro `Spring Cloud Config Server` es configurar un archivo para definir la
configuración central del servidor para que pueda ejecutarse. En nuestro caso agregaremos ciertas configuraciones
a nuestro `application.yml`, empezaremos por las siguientes configuraciones:

````yaml
server:
  port: 8888
  error:
    include-message: always

spring:
  application:
    name: config-server
````

Hay dos partes importantes a destacar en la configuración anterior. **El primero es el nombre de la aplicación.**
Es vital nombrar todos los servicios que vamos a crear en nuestra arquitectura para el descubrimiento de servicios, que
describiremos en el siguiente capítulo. **El segundo punto a tener en cuenta es el puerto en el que Spring Configuration
Server escuchará** para proporcionar los datos de configuración solicitados.

## Configurar la clase de arranque de Spring Cloud Config Server

El siguiente paso en la creación de nuestro servicio Spring Cloud Config es configurar la clase de arranque Spring Cloud
Config. Cada servicio Spring Cloud necesita una clase de arranque que podamos usar para iniciar el servicio.

Recuerde, esta clase contiene varias partes importantes: un método Java main() que actúa como punto de entrada para que
se inicie el servicio y un conjunto de anotaciones de Spring que le indican al servicio inicial qué tipo de
comportamientos Spring lanzará para el servicio. La siguiente lista muestra la clase de arranque para nuestro
`Spring Cloud Config Server`.

`Spring Cloud Config Server` proporciona una API basada en recursos HTTP para configuración externa (pares nombre-valor
o contenido YAML equivalente). El servidor se puede integrar en una aplicación Spring Boot mediante la anotación
`@EnableConfigServer`. En consecuencia, la siguiente aplicación es un servidor de configuración:

````java

@EnableConfigServer // Habilita el servicio como un servidor de configuraciones de Spring Cloud Config
@SpringBootApplication
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }

}
````

El siguiente paso es definir la ubicación de búsqueda de nuestros datos de configuración. Comencemos con el ejemplo más
simple: **el sistema de archivos.**

## Usando Spring Cloud Config Server con un sistema de archivos (filesystem)

El servidor de configuración de Spring Cloud utiliza una entrada en el archivo `application.yml` para señalar el
repositorio que contiene los datos de configuración de la aplicación. Configurar un repositorio basado en un sistema de
archivos es la forma más sencilla de lograrlo. Para hacer esto, actualicemos nuestro `application.yml`. La siguiente
lista muestra el contenido requerido para este archivo para **configurar un repositorio de sistema de archivos.**

````yml
server:
  port: 8888
  error:
    include-message: always

spring:
  application:
    name: config-server
  profiles:
    active: native

  cloud:
    config:
      server:
        #Configuración local: estas ubicaciones pueden ser classpath o ubicaciones en el sistema de archivos.
        native:
          #Lee desde una carpeta específica del sistema de archivos
          search-locations:
            file: ///${FILE_PATH}
````

Debido a que **usaremos el sistema de archivos para almacenar información de configuración de la aplicación**, debemos
decirle al `Spring Cloud Config Server` que se ejecute con el perfil `native`. Recuerde, un perfil de Spring es una
característica principal que ofrece el framework de Spring. Nos permite asignar nuestros beans a diferentes entornos,
como desarrollo, prueba, preparación, producción, native y otros.

**NOTA**
> Recuerde, `native` es solo un perfil creado para `Spring Cloud Configuration Server`, lo que indica que los archivos
> de configuración se recuperarán o leerán desde el `classpath` o el `filesystem`.

Cuando usamos un repositorio basado en un `filesystem`, también usaremos el perfil `native` **porque es un perfil
en el servidor de configuración que no usa ninguna configuración de `Git` o` Vault`**, pero carga los archivos de
configuración desde el `classpath` local o el `file system` (cualquier URL estática a la que desee señalar con
`spring.cloud.config.server.native.searchLocations`). Para utilizar el perfil nativo, inicie Config Server con
`spring.profiles.active=native`.

La última parte de `application.yml`, como se muestra en el código siguiente, proporciona la configuración de Spring
Cloud dentro del directorio donde residen los datos de la aplicación. Por ejemplo:

````yml
server:
  native:
    search-locations:
      file: ///M:/PROGRAMACION/DESARROLLO_JAVA_SPRING/08.book_ms-in-action-2021/local-config-server-repo
````

**NOTA**
> Recuerde usar el prefijo `file:` para los recursos del archivo (el valor predeterminado sin prefijo suele ser el
> `classpath`). Al igual que con cualquier configuración de Spring Boot, puede incrustar marcadores de posición de
> entorno estilo `${}`, pero recuerde que las rutas absolutas en Windows requieren un `/` adicional (por ejemplo,
> `/${user.home}/config-repo`).

**ATENCIÓN**
> El valor predeterminado de `search-locations` es idéntico al de una aplicación Spring Boot local (es
> decir, `[classpath:/, classpath:/config, file:./, file:./config]`). Esto no expone el `application.properties`
> del servidor a todos los clientes, porque cualquier fuente de propiedad presente en el servidor se elimina antes de
> enviarse al cliente.

**TIP**
> Usar un `filesystem` es excelente para comenzar rápidamente y realizar pruebas. Para usarlo en producción, debe
> asegurarse de que el sistema de archivos sea confiable y compartido en todas las instancias del Config Server.

El parámetro importante en la entrada de configuración es `search-locations`. Este parámetro proporciona una
lista separada por comas de los directorios para cada aplicación que tendrán propiedades administradas por Config
Server. En el ejemplo anterior, usamos una ubicación del sistema de archivos:

> file:///M:/PROGRAMACION/DESARROLLO_JAVA_SPRING/08.book_ms-in-action-2021/local-config-server-repo

Pero también podemos indicar un `classpath` específico para buscar nuestros datos de configuración. Esto se configura
con el siguiente código:

````yml
server:
  native:
    search-locations: classpath:/config
````

**NOTA**
> El atributo `classpath` hace que `Spring Cloud Config Server` busque en la carpeta `src/main/resources/config`.

Ahora que hemos configurado nuestro `Spring Configuration Server`, creemos nuestros archivos de propiedades del servicio
de licencia. Para simplificar este ejemplo, usaremos la ubicación de búsqueda de classpath establecida en el fragmento
de código anterior. Luego, como en el ejemplo anterior, crearemos los archivos de propiedades de licencia en una carpeta
`/config`.



