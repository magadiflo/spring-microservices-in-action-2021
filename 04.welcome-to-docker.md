# Welcome to Docker

---

## ¿Qué es Docker?

Docker es un popular motor de contenedores de código abierto basado en Linux, creado por Solomon Hykes, fundador y
director ejecutivo de dotCloud en marzo de 2013. Docker comenzó como una tecnología agradable que era responsable de
lanzar y administrar contenedores dentro de nuestras aplicaciones. Esta tecnología nos permitió compartir los recursos
de una máquina física con diferentes contenedores en lugar de exponer diferentes recursos de hardware como las máquinas
virtuales.

**Definición**
> Un `contenedor` representa un mecanismo de empaquetado lógico que proporciona a las aplicaciones todo lo que necesitan
> para ejecutarse.

Para comprender mejor cómo funciona `Docker`, es esencial tener en cuenta que `Docker Engine` es la pieza central de
todo el sistema Docker. ¿Qué es el motor Docker? Es una aplicación que sigue la arquitectura del patrón
cliente-servidor. Esta aplicación se instala en la máquina host y contiene los siguientes tres componentes críticos:
servidor, API REST e interfaz de línea de comandos (CLI). La `Figura 4.2` ilustra estos componentes de Docker, así como
otros.

![13.docker-architecture.png](./assets/13.docker-architecture.png)

Docker Engine contiene los siguientes componentes:

- `Docker daemon`: un servidor, llamado dockerd, que nos permite crear y administrar las imágenes de Docker. La API REST
  envía instrucciones al demonio y el cliente CLI ingresa los comandos de Docker.
- `Cliente Docker`: los usuarios de Docker interactúan con Docker a través de un cliente. Cuando se ejecuta un comando
  de Docker, el cliente se encarga de enviar la instrucción al demonio.
- `Docker Registry`: la ubicación donde se almacenan las imágenes de Docker. Estos registros pueden ser públicos o
  privados. Docker Hub es el lugar predeterminado para los registros públicos, pero también puede crear su propio
  registro privado.
- `Imágenes de Docker`: son plantillas de solo lectura con varias instrucciones para crear un contenedor de Docker. Las
  imágenes se pueden extraer de Docker Hub y puede usarlas tal cual o modificarlas agregando instrucciones adicionales.
  Además, puede crear nuevas imágenes utilizando un Dockerfile. Más adelante, en este capítulo, explicaremos cómo
  utilizar Dockerfiles.
- `Contenedores de Docker`: una vez creada y ejecutada con el comando docker container run, una imagen de Docker crea un
  contenedor. La aplicación y su entorno se ejecutan dentro de este contenedor. Para iniciar, detener y eliminar un
  contenedor Docker, puede utilizar la API de Docker o la CLI.
- `Volúmenes de Docker`: los volúmenes de Docker son el mecanismo preferido para almacenar datos generados por Docker y
  utilizados por los contenedores de Docker. Se pueden gestionar mediante la API de Docker o la CLI de Docker.
- `Redes Docker`: las redes Docker nos permiten conectar los contenedores a tantas redes como queramos. Podemos ver las
  redes como un medio para comunicarnos con contenedores aislados. Docker contiene los siguientes cinco tipos de
  controladores de red: bridge, host, none, overlay and macvlan.

La `Figura 4.3` muestra un diagrama de cómo funciona Docker. Tenga en cuenta que el Docker daemon es responsable de
todas las acciones del contenedor. Como se muestra en la figura 4.3, podemos ver que el demonio recibe los comandos del
cliente Docker; Estos comandos se pueden enviar a través de la CLI o las API REST. En el diagrama podemos ver cómo las
imágenes de Docker que se encuentran en los registros crean los contenedores.

![14.docker-client.png](./assets/14.docker-client.png)

## Dockerfiles

Un Dockerfile es un archivo de texto simple que contiene una lista de instrucciones y comandos que el cliente Docker
llama para crear y preparar una imagen. Este archivo automatiza el proceso de creación de imágenes para usted. Los
comandos utilizados en Dockerfile son similares a los comandos de Linux, lo que hace que Dockerfile sea más fácil de
entender.

El siguiente fragmento de código presenta un breve ejemplo de cómo se ve un Dockerfile. En la sección 4.5.1, le
mostraremos cómo crear Dockerfiles personalizados para sus propios microservicios. La `Figura 4.4` muestra cómo debería
verse el flujo de trabajo de creación de imágenes de Docker.

![15.dockerfile-creation.png](./assets/15.dockerfile-creation.png)

La `Tabla 4.1` muestra los comandos de Dockerfile más comunes que usaremos en nuestros Dockerfiles. Consulte también el
listado 4.1 para ver un Dockerfile de ejemplo.

![16.dockerfile-commands.png](./assets/16.dockerfile-commands.png)

## Docker Compose

Docker Compose simplifica el uso de Docker al permitirnos crear scripts que faciliten el diseño y la construcción de
servicios. Con Docker Compose, puede ejecutar varios contenedores como un único servicio o puede crear diferentes
contenedores simultáneamente.

Un archivo docker `compose.yml` debería verse como el que se muestra en la siguiente lista. Más adelante, en este
capítulo, explicaremos cómo crear nuestro archivo docker `compose.yml`.

## Construyendo la imagen Docker

Crearemos el archivo `Dockerfile` en la raíz de nuestro microservicio y agregaremos las instrucciones siguientes.
Para escribir estas instrucciones tomé como referencia lo desarrollador en el curso de `docker-kubernets` de
Andrés guzmán. No uso la del libro, dado que no me funcionó:

````Dockerfile
FROM eclipse-temurin:21-jdk-alpine AS build
WORKDIR /app
COPY ./pom.xml ./
COPY ./mvnw ./
COPY ./.mvn ./.mvn

RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline

COPY ./src ./src

RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app
COPY --from=build /app/target/*.jar ./app.jar
CMD ["java", "-jar", "app.jar"]                                                                                                                                                                                     docker:default  => [internal] load build definition from Dockerfile                                                                                                                                                                                     0.3s  => => transferring dockerfile: 411B                                                                                                                                                                                                     0.0s  => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                                                                                                         0.0s  => [internal] load .dockerignore                                                                                                                                                                                                        1.0s  => => transferring context: 2B                                                                                                                                                                                                          0.0s  => [build 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine                                                                                                                                                                     0.0s  => [internal] load build context                                                                                                                                                                                                        0.7s  => => transferring context: 86.46kB                                                                                                                                                                                                     0.1s  => CACHED [build 2/9] WORKDIR /app                                                                                                                                                                                                      0.0s  => [build 3/9] COPY ./pom.xml ./                                                                                                                                                                                                        0.2s  => [build 4/9] COPY ./mvnw ./                                                                                                                                                                                                           0.2s  => [build 5/9] COPY ./.mvn ./.mvn                                                                                                                                                                                                       0.2s  => [build 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                                                                                                                           1.6s  => [build 7/9] RUN ./mvnw dependency:go-offline                                                                                                                                                                                       214.5s  => [build 8/9] COPY ./src ./src                                                                                                                                                                                                         0.2s  => [build 9/9] RUN ./mvnw clean package -DskipTests                                                                                                                                                                                    18.9s  => [stage-1 3/3] COPY --from=build /app/target/*.jar ./app.jar                                                                                                                                                                          0.6s  => exporting to image                                                                                                                                                                                                                   0.3s  => => exporting layers                                                                                                                                                                                                                  0.2s  => => writing image sha256:ced60ce5ee3e0846ac654d2d2b17d9ab07c1fe0ceba9b0842a7925779eca8606                                                                                                                                             0.0s  => => naming to docker.io/library/licensing-service                                                                                                                                                                                     0.0s
````

Una vez que hemos definido las instrucciones para la construcción de la imagen, ejecutamos el siguiente comando
mediante la línea de comandos:

````bash
$ docker image build -t licensing-service .

[+] Building 239.4s (15/15) FINISHED
=> [internal] load build definition from Dockerfile
=> => transferring dockerfile: 411B
=> [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine
=> [internal] load .dockerignore
=> => transferring context: 2B
=> [build 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine
=> [internal] load build context
=> => transferring context: 86.46kB
=> CACHED [build 2/9] WORKDIR /app
=> [build 3/9] COPY ./pom.xml ./
=> [build 4/9] COPY ./mvnw ./
=> [build 5/9] COPY ./.mvn ./.mvn
=> [build 6/9] RUN sed -i -e 's/\r$//' ./mvnw
=> [build 7/9] RUN ./mvnw dependency:go-offline
=> [build 8/9] COPY ./src ./src
=> [build 9/9] RUN ./mvnw clean package -DskipTests
=> [stage-1 3/3] COPY --from=build /app/target/*.jar ./app.jar
=> exporting to image
=> => exporting layers
=> => writing image sha256:ced60ce5ee3e0846ac654d2d2b17d9ab07c1fe0ceba9b0842a7925779eca8606
=> => naming to docker.io/library/licensing-service
````

Para ver la imagen creada, podemos listar todas las imágenes y verla que allí se encuentra:

````bash
$ docker image ls

REPOSITORY                  TAG             IMAGE ID       CREATED          SIZE
licensing-service           latest          ced60ce5ee3e   14 minutes ago   366MB
...
````

## Ejecutando contenedor Docker

Como ya tenemos la imagen creada de nuestro microservicio, podemos levantar un contenedor usando la siguientes
instrucciones:

````bash
$ docker container run -d -p 8080:8080 --name c_licensing_service licensing-service:latest
````

Comprobamos que nuestro contenedor se ha creado correctamente:

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                      COMMAND                  CREATED         STATUS         PORTS                    NAMES
d61f10a7f7f6   licensing-service:latest   "/__cacert_entrypoin…"   7 seconds ago   Up 5 seconds   0.0.0.0:8080->8080/tcp   c_licensing_service
````

Realizamos una petición HTTP a uno de los endpoints expuestos por nuestro microservicio:

````bash
$ curl -v -X POST -H "Content-Type: application/json" -H "Accept-Language: es" -d "{\"licenseId\": \"0235454846\", \"description\": \"Software product\", \"productName\": \"Teclado\", \"licenseType\": \"full\"}" http://localhost:8080/v1/organization/optimaGrowth/license
>
< HTTP/1.1 200
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 166
< Date: Fri, 03 May 2024 18:42:32 GMT
<
¡Licencia creada License(id=null, licenseId=0235454846, description=Software product, organizationId=optimaGrowth, productName=Teclado, licenseType=full) con éxito!
````